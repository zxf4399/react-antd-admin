{"version":3,"file":".pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib.a5a8b84ae3c226c935be.js","mappings":"gLAeO,MAAMA,EAAY,CACvBC,KAAM,YACNC,SAwKF,SAA2BC,EAASC,GAClC,MAAMC,EAAmBC,KAAKC,OAAOC,WAAWH,iBAAiBI,KAC3DC,EAAWJ,KAAKI,SAChBC,GAAS,OAAkBD,GAGjC,IAAIE,EACJ,OAGA,SAAeC,GAGb,OAFAV,EAAQW,MAAM,qBACdF,EAASC,EACFE,EAASF,IAIlB,SAASE,EAASF,GAChB,GAAIA,IAASD,EAEX,OADAT,EAAQa,QAAQH,GACTE,EAGT,MAAME,EAAQd,EAAQe,KAAK,qBACrBC,GAAQ,OAAkBN,GAC1BO,GACHD,GAAoB,IAAVA,GAAeR,GAAWN,EAAiBgB,SAASR,GAC3DS,GACHX,GAAsB,IAAXA,GAAgBQ,GAAUd,EAAiBgB,SAASX,GAGlE,OAFAO,EAAMM,MAAQC,QAAmB,KAAXZ,EAAgBQ,EAAOA,IAAST,IAAWW,IACjEL,EAAMQ,OAASD,QAAmB,KAAXZ,EAAgBU,EAAQA,IAAUH,IAAUC,IAC5DhB,EAAGS,KAtMZa,WAQF,SAA6BC,EAAQC,GACnC,IAGIR,EAGAS,EAGAC,EAGAC,EAGAC,EAGAC,EAGAC,EAGAC,EAxBAC,GAAS,EA6Bb,OAASA,EAAQT,EAAOU,QAEtB,GACuB,UAArBV,EAAOS,GAAO,IACY,sBAA1BT,EAAOS,GAAO,GAAGE,MACjBX,EAAOS,GAAO,GAAGX,OAIjB,IAFAL,EAAOgB,EAEAhB,KAEL,GACsB,SAApBO,EAAOP,GAAM,IACY,sBAAzBO,EAAOP,GAAM,GAAGkB,MAChBX,EAAOP,GAAM,GAAGG,OAChBK,EAAQW,eAAeZ,EAAOP,GAAM,IAAIoB,WAAW,KACjDZ,EAAQW,eAAeZ,EAAOS,GAAO,IAAII,WAAW,GACtD,CAKA,IACGb,EAAOP,GAAM,GAAGK,QAAUE,EAAOS,GAAO,GAAGb,SAC3CI,EAAOS,GAAO,GAAGK,IAAIN,OAASR,EAAOS,GAAO,GAAGM,MAAMP,QAAU,MAE7DR,EAAOP,GAAM,GAAGqB,IAAIN,OACnBR,EAAOP,GAAM,GAAGsB,MAAMP,OACtBR,EAAOS,GAAO,GAAGK,IAAIN,OACrBR,EAAOS,GAAO,GAAGM,MAAMP,QACzB,GAGF,SAGFF,EACEN,EAAOP,GAAM,GAAGqB,IAAIN,OAASR,EAAOP,GAAM,GAAGsB,MAAMP,OAAS,GAC5DR,EAAOS,GAAO,GAAGK,IAAIN,OAASR,EAAOS,GAAO,GAAGM,MAAMP,OAAS,EAC1D,EACA,EACN,MAAMO,EAAQC,OAAOC,OAAO,GAAIjB,EAAOP,GAAM,GAAGqB,KAC1CA,EAAME,OAAOC,OAAO,GAAIjB,EAAOS,GAAO,GAAGM,OAC/CG,EAAUH,GAAQT,GAClBY,EAAUJ,EAAKR,GACfF,EAAkB,CAChBO,KAAML,EAAM,EAAI,iBAAmB,mBACnCS,MAAAA,EACAD,IAAKE,OAAOC,OAAO,GAAIjB,EAAOP,GAAM,GAAGqB,MAEzCT,EAAkB,CAChBM,KAAML,EAAM,EAAI,iBAAmB,mBACnCS,MAAOC,OAAOC,OAAO,GAAIjB,EAAOS,GAAO,GAAGM,OAC1CD,IAAAA,GAEFX,EAAO,CACLQ,KAAML,EAAM,EAAI,aAAe,eAC/BS,MAAOC,OAAOC,OAAO,GAAIjB,EAAOP,GAAM,GAAGqB,KACzCA,IAAKE,OAAOC,OAAO,GAAIjB,EAAOS,GAAO,GAAGM,QAE1Cb,EAAQ,CACNS,KAAML,EAAM,EAAI,SAAW,WAC3BS,MAAOC,OAAOC,OAAO,GAAIb,EAAgBW,OACzCD,IAAKE,OAAOC,OAAO,GAAIZ,EAAgBS,MAEzCd,EAAOP,GAAM,GAAGqB,IAAME,OAAOC,OAAO,GAAIb,EAAgBW,OACxDf,EAAOS,GAAO,GAAGM,MAAQC,OAAOC,OAAO,GAAIZ,EAAgBS,KAC3DP,EAAa,GAETP,EAAOP,GAAM,GAAGqB,IAAIN,OAASR,EAAOP,GAAM,GAAGsB,MAAMP,SACrDD,GAAa,OAAKA,EAAY,CAC5B,CAAC,QAASP,EAAOP,GAAM,GAAIQ,GAC3B,CAAC,OAAQD,EAAOP,GAAM,GAAIQ,MAI9BM,GAAa,OAAKA,EAAY,CAC5B,CAAC,QAASL,EAAOD,GACjB,CAAC,QAASG,EAAiBH,GAC3B,CAAC,OAAQG,EAAiBH,GAC1B,CAAC,QAASE,EAAMF,KAGlBM,GAAa,OACXA,GACA,OACEN,EAAQrB,OAAOC,WAAWsC,WAAWrC,KACrCkB,EAAOoB,MAAM3B,EAAO,EAAGgB,GACvBR,IAIJM,GAAa,OAAKA,EAAY,CAC5B,CAAC,OAAQJ,EAAMF,GACf,CAAC,QAASI,EAAiBJ,GAC3B,CAAC,OAAQI,EAAiBJ,GAC1B,CAAC,OAAQC,EAAOD,KAGdD,EAAOS,GAAO,GAAGK,IAAIN,OAASR,EAAOS,GAAO,GAAGM,MAAMP,QACvDA,EAAS,EACTD,GAAa,OAAKA,EAAY,CAC5B,CAAC,QAASP,EAAOS,GAAO,GAAIR,GAC5B,CAAC,OAAQD,EAAOS,GAAO,GAAIR,MAG7BO,EAAS,GAGX,OAAOR,EAAQP,EAAO,EAAGgB,EAAQhB,EAAO,EAAGc,GAC3CE,EAAQhB,EAAOc,EAAWG,OAASF,EAAS,EAC5C,MAQR,IAFAC,GAAS,IAEAA,EAAQT,EAAOU,QACQ,sBAA1BV,EAAOS,GAAO,GAAGE,OACnBX,EAAOS,GAAO,GAAGE,KAAO,QAI5B,OAAOX,IAiDT,SAASkB,EAAUG,EAAOb,GACxBa,EAAMC,QAAUd,EAChBa,EAAMb,QAAUA,EAChBa,EAAME,cAAgBf,I,mEC5NjB,MAAMgB,EAAW,CACtBlD,KAAM,WACNC,SAIF,SAA0BC,EAASC,EAAIgD,GACrC,IAAIC,EAAO,EACX,OAGA,SAAexC,GAMb,OALAV,EAAQW,MAAM,YACdX,EAAQW,MAAM,kBACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,kBACbf,EAAQW,MAAM,oBACPM,GAIT,SAASA,EAAKP,GACZ,OAAI,QAAWA,IACbV,EAAQa,QAAQH,GACTyC,IAGF,QAAWzC,GAAQ0C,EAAW1C,GAAQuC,EAAIvC,GAInD,SAASyC,EAAmBzC,GAC1B,OAAgB,KAATA,GAAwB,KAATA,GAAwB,KAATA,IAAe,QAAkBA,GAClE2C,EAAyB3C,GACzB0C,EAAW1C,GAIjB,SAAS2C,EAAyB3C,GAChC,OAAa,KAATA,GACFV,EAAQa,QAAQH,GACT4C,IAIG,KAAT5C,GAAwB,KAATA,GAAwB,KAATA,IAAe,QAAkBA,KAChEwC,IAAS,IAETlD,EAAQa,QAAQH,GACT2C,GAGFD,EAAW1C,GAIpB,SAAS4C,EAAU5C,GACjB,OAAa,KAATA,GACFV,EAAQe,KAAK,oBACNuB,EAAI5B,IAGA,OAATA,GAA0B,KAATA,GAAwB,KAATA,IAAe,QAAaA,GACvDuC,EAAIvC,IAGbV,EAAQa,QAAQH,GACT4C,GAIT,SAASF,EAAW1C,GAClB,OAAa,KAATA,GACFV,EAAQa,QAAQH,GAChBwC,EAAO,EACAK,IAGL,QAAW7C,IACbV,EAAQa,QAAQH,GACT0C,GAGFH,EAAIvC,GAIb,SAAS6C,EAAiB7C,GACxB,OAAO,QAAkBA,GAAQ8C,EAAW9C,GAAQuC,EAAIvC,GAI1D,SAAS8C,EAAW9C,GAClB,OAAa,KAATA,GACFV,EAAQa,QAAQH,GAChBwC,EAAO,EACAK,GAGI,KAAT7C,GAEFV,EAAQe,KAAK,oBAAoBoB,KAAO,gBACjCG,EAAI5B,IAGN+C,EAAW/C,GAIpB,SAAS+C,EAAW/C,GAClB,OAAc,KAATA,IAAe,QAAkBA,KAAUwC,IAAS,IACvDlD,EAAQa,QAAQH,GACA,KAATA,EAAc+C,EAAaD,GAG7BP,EAAIvC,GAIb,SAAS4B,EAAI5B,GAKX,OAJAV,EAAQW,MAAM,kBACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,kBACbf,EAAQe,KAAK,YACNd,M,6EChIJ,MAAMyD,EAAY,CACvB3D,SAKF,SAA2BC,EAASC,EAAIgD,GACtC,OAAO,IAAAU,GAAa3D,GAGpB,SAAyBU,GACvB,OAAgB,OAATA,IAAiB,QAAmBA,GAAQT,EAAGS,GAAQuC,EAAIvC,KAJtB,eAL9CkD,SAAS,I,6ECDJ,MAAMC,EAAa,CACxB/D,KAAM,aACNC,SAQF,SAAiCC,EAASC,EAAIgD,GAC5C,MAAMa,EAAO3D,KACb,OAGA,SAAeO,GACb,GAAa,KAATA,EAAa,CACf,MAAMqD,EAAQD,EAAKE,eAanB,OAXKD,EAAM9C,OACTjB,EAAQW,MAAM,aAAc,CAC1BsD,YAAY,IAEdF,EAAM9C,MAAO,GAGfjB,EAAQW,MAAM,oBACdX,EAAQW,MAAM,oBACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,oBACNC,EAGT,OAAOiC,EAAIvC,IAIb,SAASM,EAAMN,GACb,OAAI,QAAcA,IAChBV,EAAQW,MAAM,8BACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,8BACbf,EAAQe,KAAK,oBACNd,IAGTD,EAAQe,KAAK,oBACNd,EAAGS,MA5CZwD,aAAc,CACZnE,SAgDJ,SAAwCC,EAASC,EAAIgD,GACnD,OAAO,IAAAU,GACL3D,EACAA,EAAQmE,QAAQN,EAAY5D,EAAIgD,GAChC,aACA9C,KAAKC,OAAOC,WAAW+D,QAAQ9D,KAAKY,SAAS,qBAAkBmD,EAAY,KAnD7EtD,KAwDF,SAAcf,GACZA,EAAQe,KAAK,iB,mECjER,MAAMuD,EAAkB,CAC7BxE,KAAM,kBACNC,SAIF,SAAiCC,EAASC,EAAIgD,GAC5C,OAGA,SAAevC,GAKb,OAJAV,EAAQW,MAAM,mBACdX,EAAQW,MAAM,gBACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,gBACNE,GAIT,SAASA,EAAKP,GACZ,OAAI,QAAiBA,IACnBV,EAAQW,MAAM,wBACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,wBACbf,EAAQe,KAAK,mBACNd,GAGFgD,EAAIvC,O,6ECrBR,MAAM6D,EAAqB,CAChCzE,KAAM,qBACNC,SAIF,SAAoCC,EAASC,EAAIgD,GAC/C,MAAMa,EAAO3D,KACb,IAGIqE,EAGAC,EANAvB,EAAO,EAOX,OAGA,SAAexC,GAKb,OAJAV,EAAQW,MAAM,sBACdX,EAAQW,MAAM,4BACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,4BACNE,GAIT,SAASA,EAAKP,GACZ,OAAa,KAATA,GACFV,EAAQW,MAAM,mCACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,mCACN2D,IAGT1E,EAAQW,MAAM,2BACd6D,EAAM,GACNC,EAAO,KACAE,EAAMjE,IAIf,SAASgE,EAAQhE,GACf,OAAa,KAATA,GAAwB,MAATA,GACjBV,EAAQW,MAAM,uCACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,uCACbf,EAAQW,MAAM,2BACd6D,EAAM,EACNC,EAAO,KACAE,IAGT3E,EAAQW,MAAM,2BACd6D,EAAM,EACNC,EAAO,KACAE,EAAMjE,IAIf,SAASiE,EAAMjE,GAEb,IAAII,EAEJ,OAAa,KAATJ,GAAewC,GACjBpC,EAAQd,EAAQe,KAAK,2BAGnB0D,IAAS,OACR,OAA8BX,EAAK1B,eAAetB,KAKrDd,EAAQW,MAAM,4BACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,4BACbf,EAAQe,KAAK,sBACNd,GAPEgD,EAAIvC,IAUX+D,EAAK/D,IAASwC,IAASsB,GACzBxE,EAAQa,QAAQH,GACTiE,GAGF1B,EAAIvC,O,6ECxFR,MAAMkE,EAAa,CACxB9E,KAAM,aACNC,SAKF,SAA4BC,EAASC,EAAIgD,GACvC,MAAMa,EAAO3D,KAGP0E,EAAwB,CAC5B9E,SAuKF,SAA8BC,EAASC,EAAIgD,GACzC,IAAIC,EAAO,EACX,OAAO,IAAAS,GACL3D,GASF,SAA8BU,GAG5B,OAFAV,EAAQW,MAAM,mBACdX,EAAQW,MAAM,2BACPkB,EAAgBnB,KAVvB,aACAP,KAAKC,OAAOC,WAAW+D,QAAQ9D,KAAKY,SAAS,qBACzCmD,EACA,GAWN,SAASxC,EAAgBnB,GACvB,OAAIA,IAASD,GACXT,EAAQa,QAAQH,GAChBwC,IACOrB,GAGLqB,EAAO4B,EAAiB7B,EAAIvC,IAChCV,EAAQe,KAAK,4BACN,IAAA4C,GAAa3D,EAAS+E,EAAoB,aAA1C,CAAwDrE,IAIjE,SAASqE,EAAmBrE,GAC1B,OAAa,OAATA,IAAiB,QAAmBA,IACtCV,EAAQe,KAAK,mBACNd,EAAGS,IAGLuC,EAAIvC,KA5MbkD,SAAS,GAILoB,EAAc,CAClBjF,SA8IF,SAA6BC,EAASC,EAAIgD,GACxC,MAAMa,EAAO3D,KACb,OAGA,SAAeO,GAIb,OAHAV,EAAQW,MAAM,cACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,cACNkE,GAIT,SAASA,EAAUvE,GACjB,OAAOoD,EAAK1D,OAAO8E,KAAKpB,EAAKqB,MAAMC,MAAQnC,EAAIvC,GAAQT,EAAGS,KA3J5DkD,SAAS,GAELyB,EAAOlF,KAAKqB,OAAOrB,KAAKqB,OAAOU,OAAS,GACxCoD,EACJD,GAAyB,eAAjBA,EAAK,GAAGlD,KACZkD,EAAK,GAAGjD,eAAeiD,EAAK,IAAI,GAAMnD,OACtC,EACN,IAGIzB,EAHAqE,EAAW,EAIf,OAGA,SAAepE,GAKb,OAJAV,EAAQW,MAAM,cACdX,EAAQW,MAAM,mBACdX,EAAQW,MAAM,2BACdF,EAASC,EACF6E,EAAa7E,IAItB,SAAS6E,EAAa7E,GACpB,OAAIA,IAASD,GACXT,EAAQa,QAAQH,GAChBoE,IACOS,IAGTvF,EAAQe,KAAK,2BACN+D,EAAW,EACd7B,EAAIvC,IACJ,IAAAiD,GAAa3D,EAASwF,EAAU,aAAhC,CAA8C9E,IAIpD,SAAS8E,EAAS9E,GAChB,OAAa,OAATA,IAAiB,QAAmBA,GAC/B+E,EAAU/E,IAGnBV,EAAQW,MAAM,uBACdX,EAAQW,MAAM,cAAe,CAC3B+E,YAAa,WAERC,EAAKjF,IAId,SAASiF,EAAKjF,GACZ,OAAa,OAATA,IAAiB,QAA0BA,IAC7CV,EAAQe,KAAK,eACbf,EAAQe,KAAK,wBACN,IAAA4C,GAAa3D,EAAS4F,EAAW,aAAjC,CAA+ClF,IAG3C,KAATA,GAAeA,IAASD,EAAewC,EAAIvC,IAC/CV,EAAQa,QAAQH,GACTiF,GAIT,SAASC,EAAUlF,GACjB,OAAa,OAATA,IAAiB,QAAmBA,GAC/B+E,EAAU/E,IAGnBV,EAAQW,MAAM,uBACdX,EAAQW,MAAM,cAAe,CAC3B+E,YAAa,WAERG,EAAKnF,IAId,SAASmF,EAAKnF,GACZ,OAAa,OAATA,IAAiB,QAAmBA,IACtCV,EAAQe,KAAK,eACbf,EAAQe,KAAK,uBACN0E,EAAU/E,IAGN,KAATA,GAAeA,IAASD,EAAewC,EAAIvC,IAC/CV,EAAQa,QAAQH,GACTmF,GAIT,SAASJ,EAAU/E,GAEjB,OADAV,EAAQe,KAAK,mBACN+C,EAAKgC,UAAY7F,EAAGS,GAAQqF,EAAarF,GAIlD,SAASqF,EAAarF,GACpB,OAAa,OAATA,EACKM,EAAMN,IAGX,QAAmBA,GACdV,EAAQmE,QACba,EACAhF,EAAQmE,QACNU,EACA7D,EACAsE,GACI,IAAA3B,GACE3D,EACA+F,EACA,aACAT,EAAgB,GAElBS,GAEN/E,EAdKhB,CAeLU,IAGJV,EAAQW,MAAM,iBACPqF,EAAgBtF,IAIzB,SAASsF,EAAgBtF,GACvB,OAAa,OAATA,IAAiB,QAAmBA,IACtCV,EAAQe,KAAK,iBACNgF,EAAarF,KAGtBV,EAAQa,QAAQH,GACTsF,GAIT,SAAShF,EAAMN,GAEb,OADAV,EAAQe,KAAK,cACNd,EAAGS,KAzJZuF,UAAU,I,6ECLL,MAAMC,EAAe,CAC1BpG,KAAM,eACNC,SAUF,SAA8BC,EAASC,EAAIgD,GACzC,MAAMa,EAAO3D,KACb,OAGA,SAAeO,GAEb,OADAV,EAAQW,MAAM,iBACP,IAAAgD,GAAa3D,EAASmG,EAAkB,aAAc,EAAtD,CAA6DzF,IAItE,SAASyF,EAAiBzF,GACxB,MAAM2E,EAAOvB,EAAKtC,OAAOsC,EAAKtC,OAAOU,OAAS,GAC9C,OAAOmD,GACY,eAAjBA,EAAK,GAAGlD,MACRkD,EAAK,GAAGjD,eAAeiD,EAAK,IAAI,GAAMnD,QAAU,EAC9CkE,EAAY1F,GACZuC,EAAIvC,GAIV,SAAS0F,EAAY1F,GACnB,OAAa,OAATA,EACKM,EAAMN,IAGX,QAAmBA,GACdV,EAAQmE,QAAQkC,EAAiBD,EAAapF,EAA9ChB,CAAqDU,IAG9DV,EAAQW,MAAM,iBACP2F,EAAQ5F,IAIjB,SAAS4F,EAAQ5F,GACf,OAAa,OAATA,IAAiB,QAAmBA,IACtCV,EAAQe,KAAK,iBACNqF,EAAY1F,KAGrBV,EAAQa,QAAQH,GACT4F,GAIT,SAAStF,EAAMN,GAEb,OADAV,EAAQe,KAAK,gBACNd,EAAGS,MAtDR2F,EAAkB,CACtBtG,SA0DF,SAAiCC,EAASC,EAAIgD,GAC5C,MAAMa,EAAO3D,KACb,OAAOoC,EAGP,SAASA,EAAM7B,GAEb,OAAIoD,EAAK1D,OAAO8E,KAAKpB,EAAKqB,MAAMC,MACvBnC,EAAIvC,IAGT,QAAmBA,IACrBV,EAAQW,MAAM,cACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,cACNwB,IAGF,IAAAoB,GAAa3D,EAASoG,EAAa,aAAc,EAAjD,CAAwD1F,GAIjE,SAAS0F,EAAY1F,GACnB,MAAM2E,EAAOvB,EAAKtC,OAAOsC,EAAKtC,OAAOU,OAAS,GAC9C,OAAOmD,GACY,eAAjBA,EAAK,GAAGlD,MACRkD,EAAK,GAAGjD,eAAeiD,EAAK,IAAI,GAAMnD,QAAU,EAC9CjC,EAAGS,IACH,QAAmBA,GACnB6B,EAAM7B,GACNuC,EAAIvC,KAvFVkD,SAAS,I,mECRJ,MAAM2C,EAAW,CACtBzG,KAAM,WACNC,SA0EF,SAA0BC,EAASC,EAAIgD,GAErC,IAGIC,EAGApC,EANAgE,EAAW,EAOf,OAGA,SAAepE,GAGb,OAFAV,EAAQW,MAAM,YACdX,EAAQW,MAAM,oBACPiB,EAAgBlB,IAIzB,SAASkB,EAAgBlB,GACvB,OAAa,KAATA,GACFV,EAAQa,QAAQH,GAChBoE,IACOlD,IAGT5B,EAAQe,KAAK,oBACNyF,EAAI9F,IAIb,SAAS8F,EAAI9F,GAEX,OAAa,OAATA,EACKuC,EAAIvC,GAIA,KAATA,GACFI,EAAQd,EAAQW,MAAM,oBACtBuC,EAAO,EACArB,EAAgBnB,IAGZ,KAATA,GACFV,EAAQW,MAAM,SACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,SACNyF,IAGL,QAAmB9F,IACrBV,EAAQW,MAAM,cACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,cACNyF,IAGTxG,EAAQW,MAAM,gBACP8F,EAAK/F,IAKd,SAAS+F,EAAK/F,GACZ,OACW,OAATA,GACS,KAATA,GACS,KAATA,IACA,QAAmBA,IAEnBV,EAAQe,KAAK,gBACNyF,EAAI9F,KAGbV,EAAQa,QAAQH,GACT+F,GAKT,SAAS5E,EAAgBnB,GAEvB,OAAa,KAATA,GACFV,EAAQa,QAAQH,GAChBwC,IACOrB,GAGLqB,IAAS4B,GACX9E,EAAQe,KAAK,oBACbf,EAAQe,KAAK,YACNd,EAAGS,KAGZI,EAAMqB,KAAO,eACNsE,EAAK/F,MAzKdgG,QAKF,SAAyBlF,GACvB,IAIIS,EAGAtB,EAPAgG,EAAgBnF,EAAOU,OAAS,EAChC0E,EAAiB,EAQrB,KACsC,eAAnCpF,EAAOoF,GAAgB,GAAGzE,MACU,UAAnCX,EAAOoF,GAAgB,GAAGzE,MACO,eAAlCX,EAAOmF,GAAe,GAAGxE,MACU,UAAlCX,EAAOmF,GAAe,GAAGxE,MAI3B,IAFAF,EAAQ2E,IAEC3E,EAAQ0E,GACf,GAA8B,iBAA1BnF,EAAOS,GAAO,GAAGE,KAAyB,CAE5CX,EAAOoF,GAAgB,GAAGzE,KAAO,kBACjCX,EAAOmF,GAAe,GAAGxE,KAAO,kBAChCyE,GAAkB,EAClBD,GAAiB,EACjB,MAQN,IAHA1E,EAAQ2E,EAAiB,EACzBD,MAES1E,GAAS0E,QACFtC,IAAV1D,EACEsB,IAAU0E,GAA2C,eAA1BnF,EAAOS,GAAO,GAAGE,OAC9CxB,EAAQsB,GAGVA,IAAU0E,GACgB,eAA1BnF,EAAOS,GAAO,GAAGE,OAEjBX,EAAOb,GAAO,GAAGwB,KAAO,eAEpBF,IAAUtB,EAAQ,IACpBa,EAAOb,GAAO,GAAG2B,IAAMd,EAAOS,EAAQ,GAAG,GAAGK,IAC5Cd,EAAOqF,OAAOlG,EAAQ,EAAGsB,EAAQtB,EAAQ,GACzCgG,GAAiB1E,EAAQtB,EAAQ,EACjCsB,EAAQtB,EAAQ,GAGlBA,OAAQ0D,GAIZ,OAAO7C,GA3DPjB,SA+DF,SAAkBG,GAEhB,OACW,KAATA,GACgD,oBAAhDP,KAAKqB,OAAOrB,KAAKqB,OAAOU,OAAS,GAAG,GAAGC,Q,uFCnEpC,MAAMmE,EAAU,CACrBvG,SAsBF,SAAyBC,EAASC,GAEhC,IAAIM,EACJ,OAGA,SAAeG,GAKb,OAJAV,EAAQW,MAAM,WACdJ,EAAWP,EAAQW,MAAM,eAAgB,CACvC+E,YAAa,YAERe,EAAK/F,IAId,SAAS+F,EAAK/F,GACZ,OAAa,OAATA,EACKoG,EAAWpG,IAGhB,QAAmBA,GACdV,EAAQ+G,MACbC,EACAhB,EACAc,EAHK9G,CAILU,IAGJV,EAAQa,QAAQH,GACT+F,GAIT,SAASK,EAAWpG,GAGlB,OAFAV,EAAQe,KAAK,gBACbf,EAAQe,KAAK,WACNd,EAAGS,GAIZ,SAASsF,EAAgBtF,GAQvB,OAPAV,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,gBACbR,EAAS0G,KAAOjH,EAAQW,MAAM,eAAgB,CAC5C+E,YAAa,UACbnF,SAAAA,IAEFA,EAAWA,EAAS0G,KACbR,IArETC,QAeF,SAAwBlF,GAEtB,OADA,OAAYA,GACLA,IAbHwF,EAAwB,CAC5BjH,SAqEF,SAA8BC,EAASC,EAAIgD,GACzC,MAAMa,EAAO3D,KACb,OAGA,SAAwBO,GAKtB,OAJAV,EAAQe,KAAK,gBACbf,EAAQW,MAAM,cACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,eACN,IAAA4C,GAAa3D,EAASkH,EAAU,eAIzC,SAASA,EAASxG,GAChB,GAAa,OAATA,IAAiB,QAAmBA,GACtC,OAAOuC,EAAIvC,GAGb,MAAM2E,EAAOvB,EAAKtC,OAAOsC,EAAKtC,OAAOU,OAAS,GAE9C,OACG4B,EAAK1D,OAAOC,WAAW+D,QAAQ9D,KAAKY,SAAS,iBAC9CmE,GACiB,eAAjBA,EAAK,GAAGlD,MACRkD,EAAK,GAAGjD,eAAeiD,EAAK,IAAI,GAAMnD,QAAU,EAEzCjC,EAAGS,GAGLV,EAAQ8F,UAAUhC,EAAK1D,OAAOC,WAAW8G,KAAMlE,EAAKhD,EAApDD,CAAwDU,KAlGjEkD,SAAS,I,+HCNJ,MAAMwD,EAAa,CACxBtH,KAAM,aACNC,SAUF,SAA4BC,EAASC,EAAIgD,GACvC,MAAMa,EAAO3D,KAGb,IAAIkH,EACJ,OAGA,SAAe3G,GAEb,OADAV,EAAQW,MAAM,cACP,EAAAgD,EAAA,KACLG,EACA9D,EACAsH,EACArE,EACA,kBACA,wBACA,wBAPK,CAQLvC,IAIJ,SAAS4G,EAAW5G,GAKlB,OAJA2G,GAAa,OACXvD,EAAK1B,eAAe0B,EAAKtC,OAAOsC,EAAKtC,OAAOU,OAAS,GAAG,IAAIU,MAAM,GAAI,IAG3D,KAATlC,GACFV,EAAQW,MAAM,oBACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,qBAEN,OACLf,GACA,OACEA,EACAA,EAAQmE,QACNoD,GACA,IAAA5D,GAAa3D,EAASgB,EAAO,eAC7B,IAAA2C,GAAa3D,EAASgB,EAAO,eAE/BiC,EACA,wBACA,+BACA,qCACA,2BACA,iCAKCA,EAAIvC,GAIb,SAASM,EAAMN,GACb,OAAa,OAATA,IAAiB,QAAmBA,IACtCV,EAAQe,KAAK,cAER+C,EAAK1D,OAAOoH,QAAQtG,SAASmG,IAChCvD,EAAK1D,OAAOoH,QAAQC,KAAKJ,GAGpBpH,EAAGS,IAGLuC,EAAIvC,MAxET6G,EAAiB,CACrBxH,SA4EF,SAAuBC,EAASC,EAAIgD,GAClC,OAGA,SAAevC,GACb,OAAO,QAA0BA,IAC7B,OAAkBV,EAASQ,EAA3B,CAAmCE,GACnCuC,EAAIvC,IAIV,SAASF,EAAOE,GACd,OAAa,KAATA,GAAwB,KAATA,GAAwB,KAATA,GACzB,OACLV,GACA,IAAA2D,GAAa3D,EAASgB,EAAO,cAC7BiC,EACA,kBACA,wBACA,wBANK,CAOLvC,GAGGuC,EAAIvC,GAIb,SAASM,EAAMN,GACb,OAAgB,OAATA,IAAiB,QAAmBA,GAAQT,EAAGS,GAAQuC,EAAIvC,KAvGpEkD,SAAS,I,mECjBJ,MAAM8D,EAAkB,CAC7B5H,KAAM,kBACNC,SAIF,SAAiCC,EAASC,EAAIgD,GAC5C,OAGA,SAAevC,GAIb,OAHAV,EAAQW,MAAM,mBACdX,EAAQW,MAAM,gBACdX,EAAQa,QAAQH,GACTO,GAIT,SAASA,EAAKP,GACZ,OAAI,QAAmBA,IACrBV,EAAQe,KAAK,gBACbf,EAAQe,KAAK,mBACNd,EAAGS,IAGLuC,EAAIvC,O,uFCjBR,MAAMiH,EAAa,CACxB7H,KAAM,aACNC,SA4DF,SAA4BC,EAASC,EAAIgD,GACvC,MAAMa,EAAO3D,KACb,IAAI+C,EAAO,EACX,OAGA,SAAexC,GAGb,OAFAV,EAAQW,MAAM,cACdX,EAAQW,MAAM,sBACPiH,EAAgBlH,IAIzB,SAASkH,EAAgBlH,GACvB,OAAa,KAATA,GAAewC,IAAS,GAC1BlD,EAAQa,QAAQH,GACTkH,GAGI,OAATlH,IAAiB,QAA0BA,IAC7CV,EAAQe,KAAK,sBACN+C,EAAKgC,UAAY7F,EAAGS,GAAQmH,EAAanH,IAG3CuC,EAAIvC,GAIb,SAASmH,EAAanH,GACpB,OAAa,KAATA,GACFV,EAAQW,MAAM,sBACPC,EAASF,IAGL,OAATA,IAAiB,QAAmBA,IACtCV,EAAQe,KAAK,cACNd,EAAGS,KAGR,QAAcA,IACT,IAAAiD,GAAa3D,EAAS6H,EAAc,aAApC,CAAkDnH,IAG3DV,EAAQW,MAAM,kBACP8F,EAAK/F,IAId,SAASE,EAASF,GAChB,OAAa,KAATA,GACFV,EAAQa,QAAQH,GACTE,IAGTZ,EAAQe,KAAK,sBACN8G,EAAanH,IAItB,SAAS+F,EAAK/F,GACZ,OAAa,OAATA,GAA0B,KAATA,IAAe,QAA0BA,IAC5DV,EAAQe,KAAK,kBACN8G,EAAanH,KAGtBV,EAAQa,QAAQH,GACT+F,KA7HTC,QAIF,SAA2BlF,EAAQC,GACjC,IAII6E,EAGA3E,EAPAmF,EAAatF,EAAOU,OAAS,EAC7B6D,EAAe,EAiDnB,MAzCqC,eAAjCvE,EAAOuE,GAAc,GAAG5D,OAC1B4D,GAAgB,GAIhBe,EAAa,EAAIf,GACc,eAA/BvE,EAAOsF,GAAY,GAAG3E,OAEtB2E,GAAc,GAIiB,uBAA/BtF,EAAOsF,GAAY,GAAG3E,OACrB4D,IAAiBe,EAAa,GAC5BA,EAAa,EAAIf,GACmB,eAAnCvE,EAAOsF,EAAa,GAAG,GAAG3E,QAE9B2E,GAAcf,EAAe,IAAMe,EAAa,EAAI,GAGlDA,EAAaf,IACfO,EAAU,CACRnE,KAAM,iBACNI,MAAOf,EAAOuE,GAAc,GAAGxD,MAC/BD,IAAKd,EAAOsF,GAAY,GAAGxE,KAE7BX,EAAO,CACLQ,KAAM,YACNI,MAAOf,EAAOuE,GAAc,GAAGxD,MAC/BD,IAAKd,EAAOsF,GAAY,GAAGxE,IAE3BoD,YAAa,SAEf,OAAOlE,EAAQuE,EAAce,EAAaf,EAAe,EAAG,CAC1D,CAAC,QAASO,EAAS7E,GACnB,CAAC,QAASE,EAAMF,GAChB,CAAC,OAAQE,EAAMF,GACf,CAAC,OAAQ6E,EAAS7E,MAIfD,K,uFCxDF,MAAMsG,EAAW,CACtBhI,KAAM,WACNC,SAkCF,SAA0BC,EAASC,EAAIgD,GACrC,MAAMa,EAAO3D,KAGb,IAAI4H,EAGAC,EAGAC,EAGAhG,EAGAxB,EACJ,OAGA,SAAeC,GAIb,OAHAV,EAAQW,MAAM,YACdX,EAAQW,MAAM,gBACdX,EAAQa,QAAQH,GACTO,GAIT,SAASA,EAAKP,GACZ,OAAa,KAATA,GACFV,EAAQa,QAAQH,GACTwH,GAGI,KAATxH,GACFV,EAAQa,QAAQH,GACTyH,GAGI,KAATzH,GACFV,EAAQa,QAAQH,GAChBqH,EAAO,EAGAjE,EAAKgC,UAAY7F,EAAKmI,IAG3B,QAAW1H,IACbV,EAAQa,QAAQH,GAChBuH,EAASI,OAAOC,aAAa5H,GAC7BsH,GAAW,EACJO,GAGFtF,EAAIvC,GAIb,SAASwH,EAAiBxH,GACxB,OAAa,KAATA,GACFV,EAAQa,QAAQH,GAChBqH,EAAO,EACAS,GAGI,KAAT9H,GACFV,EAAQa,QAAQH,GAChBqH,EAAO,EACPE,EAAS,SACThG,EAAQ,EACDwG,IAGL,QAAW/H,IACbV,EAAQa,QAAQH,GAChBqH,EAAO,EACAjE,EAAKgC,UAAY7F,EAAKmI,GAGxBnF,EAAIvC,GAIb,SAAS8H,EAAkB9H,GACzB,OAAa,KAATA,GACFV,EAAQa,QAAQH,GACToD,EAAKgC,UAAY7F,EAAKmI,GAGxBnF,EAAIvC,GAIb,SAAS+H,EAAgB/H,GACvB,OAAIA,IAASuH,EAAO5F,WAAWJ,MAC7BjC,EAAQa,QAAQH,GACTuB,IAAUgG,EAAO/F,OACpB4B,EAAKgC,UACH7F,EACAiE,EACFuE,GAGCxF,EAAIvC,GAIb,SAASyH,EAAczH,GACrB,OAAI,QAAWA,IACbV,EAAQa,QAAQH,GAChBuH,EAASI,OAAOC,aAAa5H,GACtB6H,GAGFtF,EAAIvC,GAIb,SAAS6H,EAAQ7H,GACf,OACW,OAATA,GACS,KAATA,GACS,KAATA,IACA,QAA0BA,GAGf,KAATA,GACAsH,GACA,aAAsBC,EAAOS,gBAE7BX,EAAO,EACAjE,EAAKgC,UAAY7F,EAAGS,GAAQwD,EAAaxD,IAG9C,aAAwBuH,EAAOS,gBACjCX,EAAO,EAEM,KAATrH,GACFV,EAAQa,QAAQH,GACTiI,GAGF7E,EAAKgC,UAAY7F,EAAGS,GAAQwD,EAAaxD,KAGlDqH,EAAO,EAEAjE,EAAKgC,YAAchC,EAAK1D,OAAO8E,KAAKpB,EAAKqB,MAAMC,MAClDnC,EAAIvC,GACJsH,EACAY,EAA4BlI,GAC5BmI,EAAwBnI,IAGjB,KAATA,IAAe,QAAkBA,IACnCV,EAAQa,QAAQH,GAChBuH,GAAUI,OAAOC,aAAa5H,GACvB6H,GAGFtF,EAAIvC,GAIb,SAASiI,EAAiBjI,GACxB,OAAa,KAATA,GACFV,EAAQa,QAAQH,GACToD,EAAKgC,UAAY7F,EAAKiE,GAGxBjB,EAAIvC,GAIb,SAASmI,EAAwBnI,GAC/B,OAAI,QAAcA,IAChBV,EAAQa,QAAQH,GACTmI,GAGFC,EAAYpI,GAIrB,SAASkI,EAA4BlI,GACnC,OAAa,KAATA,GACFV,EAAQa,QAAQH,GACToI,GAGI,KAATpI,GAAwB,KAATA,IAAe,QAAWA,IAC3CV,EAAQa,QAAQH,GACTqI,IAGL,QAAcrI,IAChBV,EAAQa,QAAQH,GACTkI,GAGFE,EAAYpI,GAIrB,SAASqI,EAAsBrI,GAC7B,OACW,KAATA,GACS,KAATA,GACS,KAATA,GACS,KAATA,IACA,QAAkBA,IAElBV,EAAQa,QAAQH,GACTqI,GAGFC,EAA2BtI,GAIpC,SAASsI,EAA2BtI,GAClC,OAAa,KAATA,GACFV,EAAQa,QAAQH,GACTuI,IAGL,QAAcvI,IAChBV,EAAQa,QAAQH,GACTsI,GAGFJ,EAA4BlI,GAIrC,SAASuI,EAA6BvI,GACpC,OACW,OAATA,GACS,KAATA,GACS,KAATA,GACS,KAATA,GACS,KAATA,EAEOuC,EAAIvC,GAGA,KAATA,GAAwB,KAATA,GACjBV,EAAQa,QAAQH,GAChBD,EAASC,EACFwI,IAGL,QAAcxI,IAChBV,EAAQa,QAAQH,GACTuI,IAGTxI,EAAS,KACF0I,EAA+BzI,IAIxC,SAASwI,EAA6BxI,GACpC,OAAa,OAATA,IAAiB,QAAmBA,GAC/BuC,EAAIvC,GAGTA,IAASD,GACXT,EAAQa,QAAQH,GACT0I,IAGTpJ,EAAQa,QAAQH,GACTwI,GAIT,SAASC,EAA+BzI,GACtC,OACW,OAATA,GACS,KAATA,GACS,KAATA,GACS,KAATA,GACS,KAATA,GACS,KAATA,GACS,KAATA,IACA,QAA0BA,GAEnBsI,EAA2BtI,IAGpCV,EAAQa,QAAQH,GACTyI,GAIT,SAASC,EAAkC1I,GACzC,OAAa,KAATA,GAAwB,KAATA,IAAe,QAAcA,GACvCkI,EAA4BlI,GAG9BuC,EAAIvC,GAIb,SAASoI,EAAYpI,GACnB,OAAa,KAATA,GACFV,EAAQa,QAAQH,GACT2I,GAGFpG,EAAIvC,GAIb,SAAS2I,EAAc3I,GACrB,OAAI,QAAcA,IAChBV,EAAQa,QAAQH,GACT2I,GAGO,OAAT3I,IAAiB,QAAmBA,GACvCwD,EAAaxD,GACbuC,EAAIvC,GAIV,SAASwD,EAAaxD,GACpB,OAAa,KAATA,GAAwB,IAATqH,GACjB/H,EAAQa,QAAQH,GACT4I,GAGI,KAAT5I,GAAwB,IAATqH,GACjB/H,EAAQa,QAAQH,GACT6I,GAGI,KAAT7I,GAAwB,IAATqH,GACjB/H,EAAQa,QAAQH,GACT8I,GAGI,KAAT9I,GAAwB,IAATqH,GACjB/H,EAAQa,QAAQH,GACT0H,GAGI,KAAT1H,GAAwB,IAATqH,GACjB/H,EAAQa,QAAQH,GACT+I,KAGL,QAAmB/I,IAAmB,IAATqH,GAAuB,IAATA,EAQlC,OAATrH,IAAiB,QAAmBA,GAC/BgJ,EAAyBhJ,IAGlCV,EAAQa,QAAQH,GACTwD,GAZElE,EAAQ+G,MACb4C,EACAH,EACAE,EAHK1J,CAILU,GAYN,SAASgJ,EAAyBhJ,GAEhC,OADAV,EAAQe,KAAK,gBACN6I,EAAkBlJ,GAI3B,SAASkJ,EAAkBlJ,GACzB,OAAa,OAATA,EACKmJ,EAAKnJ,IAGV,QAAmBA,GACdV,EAAQmE,QACb,CACEpE,SAAU+J,EACVlG,SAAS,GAEXgG,EACAC,EANK7J,CAOLU,IAGJV,EAAQW,MAAM,gBACPuD,EAAaxD,IAItB,SAASoJ,EAAY9J,EAASC,EAAIgD,GAChC,OAGA,SAAevC,GAIb,OAHAV,EAAQW,MAAM,cACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,cACNkE,GAIT,SAASA,EAAUvE,GACjB,OAAOoD,EAAK1D,OAAO8E,KAAKpB,EAAKqB,MAAMC,MAAQnC,EAAIvC,GAAQT,EAAGS,IAK9D,SAAS4I,EAA0B5I,GACjC,OAAa,KAATA,GACFV,EAAQa,QAAQH,GACT0H,GAGFlE,EAAaxD,GAItB,SAAS6I,EAAuB7I,GAC9B,OAAa,KAATA,GACFV,EAAQa,QAAQH,GAChBuH,EAAS,GACF8B,GAGF7F,EAAaxD,GAItB,SAASqJ,EAAsBrJ,GAC7B,OAAa,KAATA,GAAe,aAAsBuH,EAAOS,gBAC9C1I,EAAQa,QAAQH,GACT8I,IAGL,QAAW9I,IAASuH,EAAO/F,OAAS,GACtClC,EAAQa,QAAQH,GAChBuH,GAAUI,OAAOC,aAAa5H,GACvBqJ,GAGF7F,EAAaxD,GAItB,SAAS+I,EAAgC/I,GACvC,OAAa,KAATA,GACFV,EAAQa,QAAQH,GACT0H,GAGFlE,EAAaxD,GAItB,SAAS0H,EAA8B1H,GACrC,OAAa,KAATA,GACFV,EAAQa,QAAQH,GACT8I,GAGI,KAAT9I,GAAwB,IAATqH,GACjB/H,EAAQa,QAAQH,GACT0H,GAGFlE,EAAaxD,GAItB,SAAS8I,EAAkB9I,GACzB,OAAa,OAATA,IAAiB,QAAmBA,IACtCV,EAAQe,KAAK,gBACN8I,EAAKnJ,KAGdV,EAAQa,QAAQH,GACT8I,GAIT,SAASK,EAAKnJ,GAEZ,OADAV,EAAQe,KAAK,YACNd,EAAGS,KA3gBZsJ,UAWF,SAA2BxI,GACzB,IAAIS,EAAQT,EAAOU,OAEnB,KAAOD,MACoB,UAArBT,EAAOS,GAAO,IAA4C,aAA1BT,EAAOS,GAAO,GAAGE,QAcvD,OATIF,EAAQ,GAAmC,eAA9BT,EAAOS,EAAQ,GAAG,GAAGE,OAEpCX,EAAOS,GAAO,GAAGM,MAAQf,EAAOS,EAAQ,GAAG,GAAGM,MAE9Cf,EAAOS,EAAQ,GAAG,GAAGM,MAAQf,EAAOS,EAAQ,GAAG,GAAGM,MAElDf,EAAOqF,OAAO5E,EAAQ,EAAG,IAGpBT,GA5BPyE,UAAU,GAIN0D,EAAqB,CACzB5J,SA0gBF,SAA2BC,EAASC,EAAIgD,GACtC,OAGA,SAAevC,GAKb,OAJAV,EAAQe,KAAK,gBACbf,EAAQW,MAAM,mBACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,mBACNf,EAAQmE,QAAQ,IAAWlE,EAAIgD,KAlhBxCW,SAAS,I,6ECZJ,MAAMqG,EAAW,CACtBnK,KAAM,WACNC,SAIF,SAA0BC,EAASC,EAAIgD,GACrC,MAAMa,EAAO3D,KAGb,IAAIM,EAGAwH,EAGAhG,EAGAiI,EACJ,OAGA,SAAexJ,GAIb,OAHAV,EAAQW,MAAM,YACdX,EAAQW,MAAM,gBACdX,EAAQa,QAAQH,GACTO,GAIT,SAASA,EAAKP,GACZ,OAAa,KAATA,GACFV,EAAQa,QAAQH,GACTyJ,GAGI,KAATzJ,GACFV,EAAQa,QAAQH,GACTyH,GAGI,KAATzH,GACFV,EAAQa,QAAQH,GACT0J,IAGL,QAAW1J,IACbV,EAAQa,QAAQH,GACT2J,GAGFpH,EAAIvC,GAIb,SAASyJ,EAAgBzJ,GACvB,OAAa,KAATA,GACFV,EAAQa,QAAQH,GACT4J,GAGI,KAAT5J,GACFV,EAAQa,QAAQH,GAChBuH,EAAS,SACThG,EAAQ,EACDsI,IAGL,QAAW7J,IACbV,EAAQa,QAAQH,GACT8J,GAGFvH,EAAIvC,GAIb,SAAS4J,EAAY5J,GACnB,OAAa,KAATA,GACFV,EAAQa,QAAQH,GACT+J,GAGFxH,EAAIvC,GAIb,SAAS+J,EAAa/J,GACpB,OAAa,OAATA,GAA0B,KAATA,EACZuC,EAAIvC,GAGA,KAATA,GACFV,EAAQa,QAAQH,GACTgK,GAGFC,EAAQjK,GAIjB,SAASgK,EAAiBhK,GACxB,OAAa,OAATA,GAA0B,KAATA,EACZuC,EAAIvC,GAGNiK,EAAQjK,GAIjB,SAASiK,EAAQjK,GACf,OAAa,OAATA,EACKuC,EAAIvC,GAGA,KAATA,GACFV,EAAQa,QAAQH,GACTkK,IAGL,QAAmBlK,IACrBwJ,EAAcS,EACPE,EAAanK,KAGtBV,EAAQa,QAAQH,GACTiK,GAIT,SAASC,EAAalK,GACpB,OAAa,KAATA,GACFV,EAAQa,QAAQH,GACT4B,GAGFqI,EAAQjK,GAIjB,SAAS6J,EAAU7J,GACjB,OAAIA,IAASuH,EAAO5F,WAAWJ,MAC7BjC,EAAQa,QAAQH,GACTuB,IAAUgG,EAAO/F,OAAS4I,EAAQP,GAGpCtH,EAAIvC,GAIb,SAASoK,EAAMpK,GACb,OAAa,OAATA,EACKuC,EAAIvC,GAGA,KAATA,GACFV,EAAQa,QAAQH,GACTqK,IAGL,QAAmBrK,IACrBwJ,EAAcY,EACPD,EAAanK,KAGtBV,EAAQa,QAAQH,GACToK,GAIT,SAASC,EAAWrK,GAClB,OAAa,KAATA,GACFV,EAAQa,QAAQH,GACTsK,GAGFF,EAAMpK,GAIf,SAASsK,EAAStK,GAChB,OAAa,KAATA,EACK4B,EAAI5B,GAGA,KAATA,GACFV,EAAQa,QAAQH,GACTsK,GAGFF,EAAMpK,GAIf,SAAS8J,EAAY9J,GACnB,OAAa,OAATA,GAA0B,KAATA,EACZ4B,EAAI5B,IAGT,QAAmBA,IACrBwJ,EAAcM,EACPK,EAAanK,KAGtBV,EAAQa,QAAQH,GACT8J,GAIT,SAASJ,EAAY1J,GACnB,OAAa,OAATA,EACKuC,EAAIvC,GAGA,KAATA,GACFV,EAAQa,QAAQH,GACTuK,IAGL,QAAmBvK,IACrBwJ,EAAcE,EACPS,EAAanK,KAGtBV,EAAQa,QAAQH,GACT0J,GAIT,SAASa,EAAiBvK,GACxB,OAAgB,KAATA,EAAc4B,EAAI5B,GAAQ0J,EAAY1J,GAI/C,SAASyH,EAAczH,GACrB,OAAI,QAAWA,IACbV,EAAQa,QAAQH,GACTwK,GAGFjI,EAAIvC,GAIb,SAASwK,EAASxK,GAChB,OAAa,KAATA,IAAe,QAAkBA,IACnCV,EAAQa,QAAQH,GACTwK,GAGFC,EAAgBzK,GAIzB,SAASyK,EAAgBzK,GACvB,OAAI,QAAmBA,IACrBwJ,EAAciB,EACPN,EAAanK,KAGlB,QAAcA,IAChBV,EAAQa,QAAQH,GACTyK,GAGF7I,EAAI5B,GAIb,SAAS2J,EAAQ3J,GACf,OAAa,KAATA,IAAe,QAAkBA,IACnCV,EAAQa,QAAQH,GACT2J,GAGI,KAAT3J,GAAwB,KAATA,IAAe,QAA0BA,GACnD0K,EAAe1K,GAGjBuC,EAAIvC,GAIb,SAAS0K,EAAe1K,GACtB,OAAa,KAATA,GACFV,EAAQa,QAAQH,GACT4B,GAGI,KAAT5B,GAAwB,KAATA,IAAe,QAAWA,IAC3CV,EAAQa,QAAQH,GACT2K,IAGL,QAAmB3K,IACrBwJ,EAAckB,EACPP,EAAanK,KAGlB,QAAcA,IAChBV,EAAQa,QAAQH,GACT0K,GAGF9I,EAAI5B,GAIb,SAAS2K,EAAqB3K,GAC5B,OACW,KAATA,GACS,KAATA,GACS,KAATA,GACS,KAATA,IACA,QAAkBA,IAElBV,EAAQa,QAAQH,GACT2K,GAGFC,EAA0B5K,GAInC,SAAS4K,EAA0B5K,GACjC,OAAa,KAATA,GACFV,EAAQa,QAAQH,GACT6K,IAGL,QAAmB7K,IACrBwJ,EAAcoB,EACPT,EAAanK,KAGlB,QAAcA,IAChBV,EAAQa,QAAQH,GACT4K,GAGFF,EAAe1K,GAIxB,SAAS6K,EAA4B7K,GACnC,OACW,OAATA,GACS,KAATA,GACS,KAATA,GACS,KAATA,GACS,KAATA,EAEOuC,EAAIvC,GAGA,KAATA,GAAwB,KAATA,GACjBV,EAAQa,QAAQH,GAChBD,EAASC,EACF8K,IAGL,QAAmB9K,IACrBwJ,EAAcqB,EACPV,EAAanK,KAGlB,QAAcA,IAChBV,EAAQa,QAAQH,GACT6K,IAGTvL,EAAQa,QAAQH,GAChBD,OAAS4D,EACFoH,GAIT,SAASD,EAA4B9K,GACnC,OAAIA,IAASD,GACXT,EAAQa,QAAQH,GACTgL,GAGI,OAAThL,EACKuC,EAAIvC,IAGT,QAAmBA,IACrBwJ,EAAcsB,EACPX,EAAanK,KAGtBV,EAAQa,QAAQH,GACT8K,GAIT,SAASE,EAAiChL,GACxC,OAAa,KAATA,GAAwB,KAATA,IAAe,QAA0BA,GACnD0K,EAAe1K,GAGjBuC,EAAIvC,GAIb,SAAS+K,EAA8B/K,GACrC,OACW,OAATA,GACS,KAATA,GACS,KAATA,GACS,KAATA,GACS,KAATA,GACS,KAATA,EAEOuC,EAAIvC,GAGA,KAATA,IAAe,QAA0BA,GACpC0K,EAAe1K,IAGxBV,EAAQa,QAAQH,GACT+K,GAMT,SAASZ,EAAanK,GAKpB,OAJAV,EAAQe,KAAK,gBACbf,EAAQW,MAAM,cACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,eACN,IAAA4C,GACL3D,EACAoG,EACA,aACAtC,EAAK1D,OAAOC,WAAW+D,QAAQ9D,KAAKY,SAAS,qBACzCmD,EACA,GAKR,SAAS+B,EAAY1F,GAEnB,OADAV,EAAQW,MAAM,gBACPuJ,EAAYxJ,GAIrB,SAAS4B,EAAI5B,GACX,OAAa,KAATA,GACFV,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,gBACbf,EAAQe,KAAK,YACNd,GAGFgD,EAAIvC,O,yICzcR,MAAMiL,EAAW,CACtB7L,KAAM,WACNC,SAgJF,SAA0BC,EAASC,EAAIgD,GACrC,MAAMa,EAAO3D,KACb,IAGIyL,EAGApE,EANAvF,EAAQ6B,EAAKtC,OAAOU,OAQxB,KAAOD,KACL,IACkC,eAA/B6B,EAAKtC,OAAOS,GAAO,GAAGE,MACU,cAA/B2B,EAAKtC,OAAOS,GAAO,GAAGE,QACvB2B,EAAKtC,OAAOS,GAAO,GAAG4J,UACvB,CACAD,EAAa9H,EAAKtC,OAAOS,GAAO,GAChC,MAIJ,OAGA,SAAevB,GACb,OAAKkL,EAIDA,EAAWE,UAAkBC,EAASrL,IAC1C8G,EAAU1D,EAAK1D,OAAOoH,QAAQtG,UAC5B,OACE4C,EAAK1B,eAAe,CAClBG,MAAOqJ,EAAWtJ,IAClBA,IAAKwB,EAAKqB,UAIhBnF,EAAQW,MAAM,YACdX,EAAQW,MAAM,eACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,eACbf,EAAQe,KAAK,YACNiL,GAjBE/I,EAAIvC,IAqBf,SAASsL,EAActL,GAErB,OAAa,KAATA,EACKV,EAAQmE,QACb8H,EACAhM,EACAuH,EAAUvH,EAAK8L,EAHV/L,CAILU,GAGS,KAATA,EACKV,EAAQmE,QACb+H,EACAjM,EACAuH,EACIxH,EAAQmE,QAAQgI,EAA6BlM,EAAI8L,GACjDA,EALC/L,CAMLU,GAGG8G,EAAUvH,EAAGS,GAAQqL,EAASrL,GAIvC,SAASqL,EAASrL,GAEhB,OADAkL,EAAWC,WAAY,EAChB5I,EAAIvC,KAxNbsJ,UA6CF,SAA2BxI,EAAQC,GACjC,IAIIX,EAGAG,EAGAE,EAGAiL,EAbAnK,EAAQT,EAAOU,OACfF,EAAS,EAcb,KAAOC,KAGL,GAFAnB,EAAQU,EAAOS,GAAO,GAElBhB,EAAM,CAER,GACiB,SAAfH,EAAMqB,MACU,cAAfrB,EAAMqB,MAAwBrB,EAAMgL,UAErC,MAIuB,UAArBtK,EAAOS,GAAO,IAAiC,cAAfnB,EAAMqB,OACxCrB,EAAMgL,WAAY,QAEf,GAAI3K,GACT,GACuB,UAArBK,EAAOS,GAAO,KACE,eAAfnB,EAAMqB,MAAwC,cAAfrB,EAAMqB,QACrCrB,EAAM+K,YAEP5K,EAAOgB,EAEY,cAAfnB,EAAMqB,MAAsB,CAC9BH,EAAS,EACT,WAGoB,aAAflB,EAAMqB,OACfhB,EAAQc,GAIZ,MAAMP,EAAQ,CACZS,KAA+B,cAAzBX,EAAOP,GAAM,GAAGkB,KAAuB,OAAS,QACtDI,MAAOC,OAAOC,OAAO,GAAIjB,EAAOP,GAAM,GAAGsB,OACzCD,IAAKE,OAAOC,OAAO,GAAIjB,EAAOA,EAAOU,OAAS,GAAG,GAAGI,MAEhD+J,EAAQ,CACZlK,KAAM,QACNI,MAAOC,OAAOC,OAAO,GAAIjB,EAAOP,GAAM,GAAGsB,OACzCD,IAAKE,OAAOC,OAAO,GAAIjB,EAAOL,GAAO,GAAGmB,MAEpCX,EAAO,CACXQ,KAAM,YACNI,MAAOC,OAAOC,OAAO,GAAIjB,EAAOP,EAAOe,EAAS,GAAG,GAAGM,KACtDA,IAAKE,OAAOC,OAAO,GAAIjB,EAAOL,EAAQ,GAAG,GAAGoB,QA+B9C,OA7BA6J,EAAQ,CACN,CAAC,QAAS1K,EAAOD,GACjB,CAAC,QAAS4K,EAAO5K,IAGnB2K,GAAQ,OAAKA,EAAO5K,EAAOoB,MAAM3B,EAAO,EAAGA,EAAOe,EAAS,IAE3DoK,GAAQ,OAAKA,EAAO,CAAC,CAAC,QAASzK,EAAMF,KAErC2K,GAAQ,OACNA,GACA,OACE3K,EAAQrB,OAAOC,WAAWsC,WAAWrC,KACrCkB,EAAOoB,MAAM3B,EAAOe,EAAS,EAAGb,EAAQ,GACxCM,IAIJ2K,GAAQ,OAAKA,EAAO,CAClB,CAAC,OAAQzK,EAAMF,GACfD,EAAOL,EAAQ,GACfK,EAAOL,EAAQ,GACf,CAAC,OAAQkL,EAAO5K,KAGlB2K,GAAQ,OAAKA,EAAO5K,EAAOoB,MAAMzB,EAAQ,IAEzCiL,GAAQ,OAAKA,EAAO,CAAC,CAAC,OAAQ1K,EAAOD,MACrC,OAAOD,EAAQP,EAAMO,EAAOU,OAAQkK,GAC7B5K,GA1IPD,WAmBF,SAA4BC,GAC1B,IAGIV,EAHAmB,GAAS,EAKb,OAASA,EAAQT,EAAOU,QACtBpB,EAAQU,EAAOS,GAAO,GAGL,eAAfnB,EAAMqB,MACS,cAAfrB,EAAMqB,MACS,aAAfrB,EAAMqB,OAGNX,EAAOqF,OAAO5E,EAAQ,EAAkB,eAAfnB,EAAMqB,KAAwB,EAAI,GAC3DrB,EAAMqB,KAAO,OACbF,KAIJ,OAAOT,IApCHyK,EAAoB,CACxBlM,SAuNF,SAA0BC,EAASC,EAAIgD,GACrC,OAGA,SAAevC,GAKb,OAJAV,EAAQW,MAAM,YACdX,EAAQW,MAAM,kBACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,mBACN,OAAkBf,EAASiB,IAIpC,SAASA,EAAKP,GACZ,OAAa,KAATA,EACK4B,EAAI5B,IAGN,OACLV,EACAsM,EACArJ,EACA,sBACA,6BACA,mCACA,yBACA,4BACA,GATK,CAULvC,GAIJ,SAAS4L,EAAiB5L,GACxB,OAAO,QAA0BA,IAC7B,OAAkBV,EAASuM,EAA3B,CAAoC7L,GACpC4B,EAAI5B,GAIV,SAAS6L,EAAQ7L,GACf,OAAa,KAATA,GAAwB,KAATA,GAAwB,KAATA,GACzB,OACLV,GACA,OAAkBA,EAASsC,GAC3BW,EACA,gBACA,sBACA,sBANK,CAOLvC,GAGG4B,EAAI5B,GAIb,SAAS4B,EAAI5B,GACX,OAAa,KAATA,GACFV,EAAQW,MAAM,kBACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,kBACbf,EAAQe,KAAK,YACNd,GAGFgD,EAAIvC,MAnRTwL,EAAyB,CAC7BnM,SAuRF,SAA+BC,EAASC,EAAIgD,GAC1C,MAAMa,EAAO3D,KACb,OAGA,SAAeO,GACb,OAAO,EAAAiD,EAAA,KACLG,EACA9D,EACAwM,EACAvJ,EACA,YACA,kBACA,kBAPK,CAQLvC,IAIJ,SAAS8L,EAAW9L,GAClB,OAAOoD,EAAK1D,OAAOoH,QAAQtG,UACzB,OACE4C,EAAK1B,eAAe0B,EAAKtC,OAAOsC,EAAKtC,OAAOU,OAAS,GAAG,IAAIU,MAAM,GAAI,KAGtE3C,EAAGS,GACHuC,EAAIvC,MA5SNyL,EAA8B,CAClCpM,SAgTF,SAAoCC,EAASC,EAAIgD,GAC/C,OAGA,SAAevC,GAKb,OAJAV,EAAQW,MAAM,aACdX,EAAQW,MAAM,mBACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,mBACNE,GAIT,SAASA,EAAKP,GACZ,OAAa,KAATA,GACFV,EAAQW,MAAM,mBACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,mBACbf,EAAQe,KAAK,aACNd,GAGFgD,EAAIvC,O,qDCpWR,MAAM+L,EAAkB,CAC7B3M,KAAM,kBACNC,SAKF,SAAiCC,EAASC,EAAIgD,GAC5C,MAAMa,EAAO3D,KACb,OAGA,SAAeO,GAKb,OAJAV,EAAQW,MAAM,cACdX,EAAQW,MAAM,oBACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,oBACNE,GAIT,SAASA,EAAKP,GACZ,OAAa,KAATA,GACFV,EAAQW,MAAM,eACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,eACbf,EAAQe,KAAK,cACNC,GAGFiC,EAAIvC,GAIb,SAASM,EAAMN,GAQb,OAAgB,KAATA,GAAe,2BAA4BoD,EAAK1D,OAAOC,WAC1D4C,EAAIvC,GACJT,EAAGS,KAzCTa,W,QAAY,e,qDCHP,MAAMmL,EAAiB,CAC5B5M,KAAM,iBACNC,SAKF,SAAgCC,EAASC,EAAIgD,GAC3C,MAAMa,EAAO3D,KACb,OAGA,SAAeO,GAMb,OALAV,EAAQW,MAAM,aACdX,EAAQW,MAAM,eACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,eACbf,EAAQe,KAAK,aACNC,GAIT,SAASA,EAAMN,GAQb,OAAgB,KAATA,GAAe,2BAA4BoD,EAAK1D,OAAOC,WAC1D4C,EAAIvC,GACJT,EAAGS,KA7BTa,W,QAAY,e,mECFP,MAAMoL,EAAa,CACxB7M,KAAM,aACNC,SAIF,SAA4BC,EAASC,GACnC,OAGA,SAAeS,GAIb,OAHAV,EAAQW,MAAM,cACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,eACN,IAAA4C,GAAa3D,EAASC,EAAI,kB,iGCJ9B,MAAM2M,EAAO,CAClB9M,KAAM,OACNC,SAuBF,SAA2BC,EAASC,EAAIgD,GACtC,MAAMa,EAAO3D,KACPkF,EAAOvB,EAAKtC,OAAOsC,EAAKtC,OAAOU,OAAS,GAC9C,IAAI2K,EACFxH,GAAyB,eAAjBA,EAAK,GAAGlD,KACZkD,EAAK,GAAGjD,eAAeiD,EAAK,IAAI,GAAMnD,OACtC,EACFgB,EAAO,EACX,OAGA,SAAexC,GACb,MAAMqH,EACJjE,EAAKE,eAAe7B,OACV,KAATzB,GAAwB,KAATA,GAAwB,KAATA,EAC3B,gBACA,eAEN,GACW,kBAATqH,GACKjE,EAAKE,eAAevD,QAAUC,IAASoD,EAAKE,eAAevD,QAC5D,QAAWC,GACf,CAQA,GAPKoD,EAAKE,eAAe7B,OACvB2B,EAAKE,eAAe7B,KAAO4F,EAC3B/H,EAAQW,MAAMoH,EAAM,CAClB9D,YAAY,KAIH,kBAAT8D,EAEF,OADA/H,EAAQW,MAAM,kBACE,KAATD,GAAwB,KAATA,EAClBV,EAAQ+G,MAAM,IAAe9D,EAAK6J,EAAlC9M,CAA4CU,GAC5CoM,EAASpM,GAGf,IAAKoD,EAAKgC,WAAsB,KAATpF,EAGrB,OAFAV,EAAQW,MAAM,kBACdX,EAAQW,MAAM,iBACPoM,EAAOrM,GAIlB,OAAOuC,EAAIvC,IAIb,SAASqM,EAAOrM,GACd,OAAI,QAAWA,MAAWwC,EAAO,IAC/BlD,EAAQa,QAAQH,GACTqM,KAILjJ,EAAKgC,WAAa5C,EAAO,KAC1BY,EAAKE,eAAevD,OACjBC,IAASoD,EAAKE,eAAevD,OACpB,KAATC,GAAwB,KAATA,IAEnBV,EAAQe,KAAK,iBACN+L,EAASpM,IAGXuC,EAAIvC,GAMb,SAASoM,EAASpM,GAKhB,OAJAV,EAAQW,MAAM,kBACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,kBACb+C,EAAKE,eAAevD,OAASqD,EAAKE,eAAevD,QAAUC,EACpDV,EAAQ+G,MACb,IACAjD,EAAKgC,UAAY7C,EAAM+J,EACvBhN,EAAQmE,QACN8I,EACAC,EACAC,IAMN,SAASH,EAAQtM,GAGf,OAFAoD,EAAKE,eAAeoJ,kBAAmB,EACvCP,IACOK,EAAYxM,GAIrB,SAASyM,EAAYzM,GACnB,OAAI,QAAcA,IAChBV,EAAQW,MAAM,4BACdX,EAAQa,QAAQH,GAChBV,EAAQe,KAAK,4BACNmM,GAGFjK,EAAIvC,GAIb,SAASwM,EAAYxM,GAInB,OAHAoD,EAAKE,eAAed,KAClB2J,EACA/I,EAAK1B,eAAepC,EAAQe,KAAK,mBAAmB,GAAMmB,OACrDjC,EAAGS,KApIZwD,aAAc,CACZnE,SA2IJ,SAAkCC,EAASC,EAAIgD,GAC7C,MAAMa,EAAO3D,KAEb,OADA2D,EAAKE,eAAeqJ,gBAAahJ,EAC1BrE,EAAQ+G,MAAM,KAGrB,SAAiBrG,GAMf,OALAoD,EAAKE,eAAesJ,kBAClBxJ,EAAKE,eAAesJ,mBACpBxJ,EAAKE,eAAeoJ,kBAGf,IAAAzJ,GACL3D,EACAC,EACA,iBACA6D,EAAKE,eAAed,KAAO,EAJtB,CAKLxC,MAIJ,SAAkBA,GAChB,OAAIoD,EAAKE,eAAesJ,qBAAsB,QAAc5M,IAC1DoD,EAAKE,eAAesJ,uBAAoBjJ,EACxCP,EAAKE,eAAeoJ,sBAAmB/I,EAChCkJ,EAAiB7M,KAG1BoD,EAAKE,eAAesJ,uBAAoBjJ,EACxCP,EAAKE,eAAeoJ,sBAAmB/I,EAChCrE,EAAQmE,QAAQqJ,EAAiBvN,EAAIsN,EAArCvN,CAAuDU,OAIhE,SAAS6M,EAAiB7M,GAKxB,OAHAoD,EAAKE,eAAeqJ,YAAa,EAEjCvJ,EAAKgC,eAAYzB,GACV,IAAAV,GACL3D,EACAA,EAAQmE,QAAQyI,EAAM3M,EAAIgD,GAC1B,aACAa,EAAK1D,OAAOC,WAAW+D,QAAQ9D,KAAKY,SAAS,qBACzCmD,EACA,EANC,CAOL3D,MAvLJK,KAuNF,SAAyBf,GACvBA,EAAQe,KAAKZ,KAAK6D,eAAe7B,QApN7B8K,EAAoC,CACxClN,SA0NF,SAA0CC,EAASC,EAAIgD,GACrD,MAAMa,EAAO3D,KACb,OAAO,IAAAwD,GACL3D,GASF,SAAqBU,GACnB,MAAM2E,EAAOvB,EAAKtC,OAAOsC,EAAKtC,OAAOU,OAAS,GAC9C,QAAQ,QAAcxB,IACpB2E,GACiB,6BAAjBA,EAAK,GAAGlD,KACNlC,EAAGS,GACHuC,EAAIvC,KAbR,2BACAoD,EAAK1D,OAAOC,WAAW+D,QAAQ9D,KAAKY,SAAS,qBACzCmD,EACA,IAjONT,SAAS,GAIL4J,EAAkB,CACtBzN,SAoLF,SAAwBC,EAASC,EAAIgD,GACnC,MAAMa,EAAO3D,KACb,OAAO,IAAAwD,GACL3D,GAOF,SAAqBU,GACnB,MAAM2E,EAAOvB,EAAKtC,OAAOsC,EAAKtC,OAAOU,OAAS,GAC9C,OAAOmD,GACY,mBAAjBA,EAAK,GAAGlD,MACRkD,EAAK,GAAGjD,eAAeiD,EAAK,IAAI,GAAMnD,SAAW4B,EAAKE,eAAed,KACnEjD,EAAGS,GACHuC,EAAIvC,KAXR,iBACAoD,EAAKE,eAAed,KAAO,IAzL7BU,SAAS,I,6EC1BJ,MAAM6J,EAAkB,CAC7B3N,KAAM,kBACNC,SA+DF,SAAiCC,EAASC,EAAIgD,GAC5C,MAAMa,EAAO3D,KACb,IAGIM,EAGAiN,EANAzL,EAAQ6B,EAAKtC,OAAOU,OAQxB,KAAOD,KAGL,GACiC,eAA/B6B,EAAKtC,OAAOS,GAAO,GAAGE,MACS,eAA/B2B,EAAKtC,OAAOS,GAAO,GAAGE,MACS,YAA/B2B,EAAKtC,OAAOS,GAAO,GAAGE,KACtB,CACAuL,EAA2C,cAA/B5J,EAAKtC,OAAOS,GAAO,GAAGE,KAClC,MAIJ,OAGA,SAAezB,GACb,OAAKoD,EAAK1D,OAAO8E,KAAKpB,EAAKqB,MAAMC,QAAUtB,EAAKgC,YAAa4H,EAOtDzK,EAAIvC,IANTV,EAAQW,MAAM,qBACdX,EAAQW,MAAM,6BACdF,EAASC,EACFmB,EAAgBnB,KAO3B,SAASmB,EAAgBnB,GACvB,OAAIA,IAASD,GACXT,EAAQa,QAAQH,GACTmB,IAGT7B,EAAQe,KAAK,8BACN,IAAA4C,GAAa3D,EAAS+E,EAAoB,aAA1C,CAAwDrE,IAIjE,SAASqE,EAAmBrE,GAC1B,OAAa,OAATA,IAAiB,QAAmBA,IACtCV,EAAQe,KAAK,qBACNd,EAAGS,IAGLuC,EAAIvC,KArHbsJ,UAIF,SAAkCxI,EAAQC,GACxC,IAGI6E,EAGA3E,EAGAyF,EATAnF,EAAQT,EAAOU,OAYnB,KAAOD,KACL,GAAyB,UAArBT,EAAOS,GAAO,GAAgB,CAChC,GAA8B,YAA1BT,EAAOS,GAAO,GAAGE,KAAoB,CACvCmE,EAAUrE,EACV,MAG4B,cAA1BT,EAAOS,GAAO,GAAGE,OACnBR,EAAOM,OAIqB,YAA1BT,EAAOS,GAAO,GAAGE,MAEnBX,EAAOqF,OAAO5E,EAAO,GAGlBmF,GAAwC,eAA1B5F,EAAOS,GAAO,GAAGE,OAClCiF,EAAanF,GAKnB,MAAM0L,EAAU,CACdxL,KAAM,gBACNI,MAAOC,OAAOC,OAAO,GAAIjB,EAAOG,GAAM,GAAGY,OACzCD,IAAKE,OAAOC,OAAO,GAAIjB,EAAOA,EAAOU,OAAS,GAAG,GAAGI,MAetD,OAZAd,EAAOG,GAAM,GAAGQ,KAAO,oBAGnBiF,GACF5F,EAAOqF,OAAOlF,EAAM,EAAG,CAAC,QAASgM,EAASlM,IAC1CD,EAAOqF,OAAOO,EAAa,EAAG,EAAG,CAAC,OAAQ5F,EAAO8E,GAAS,GAAI7E,IAC9DD,EAAO8E,GAAS,GAAGhE,IAAME,OAAOC,OAAO,GAAIjB,EAAO4F,GAAY,GAAG9E,MAEjEd,EAAO8E,GAAS,GAAKqH,EAGvBnM,EAAOiG,KAAK,CAAC,OAAQkG,EAASlM,IACvBD,K,6EC9DF,MAAMoM,EAAgB,CAC3B9N,KAAM,gBACNC,SAIF,SAA+BC,EAASC,EAAIgD,GAC1C,IAGIxC,EAHAyC,EAAO,EAIX,OAGA,SAAexC,GAGb,OAFAV,EAAQW,MAAM,iBACdF,EAASC,EACFmN,EAAQnN,IAIjB,SAASmN,EAAQnN,GACf,OAAIA,IAASD,GACXT,EAAQW,MAAM,yBACPC,EAASF,KAGd,QAAcA,IACT,IAAAiD,GAAa3D,EAAS6N,EAAS,aAA/B,CAA6CnN,GAGlDwC,EAAO,GAAe,OAATxC,KAAkB,QAAmBA,GAC7CuC,EAAIvC,IAGbV,EAAQe,KAAK,iBACNd,EAAGS,IAIZ,SAASE,EAASF,GAChB,OAAIA,IAASD,GACXT,EAAQa,QAAQH,GAChBwC,IACOtC,IAGTZ,EAAQe,KAAK,yBACN8M,EAAQnN","sources":["webpack://tech-stack/./node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/attention.js","webpack://tech-stack/./node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/autolink.js","webpack://tech-stack/./node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/blank-line.js","webpack://tech-stack/./node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/block-quote.js","webpack://tech-stack/./node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/character-escape.js","webpack://tech-stack/./node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/character-reference.js","webpack://tech-stack/./node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/code-fenced.js","webpack://tech-stack/./node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/code-indented.js","webpack://tech-stack/./node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/code-text.js","webpack://tech-stack/./node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/content.js","webpack://tech-stack/./node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/definition.js","webpack://tech-stack/./node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/hard-break-escape.js","webpack://tech-stack/./node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/heading-atx.js","webpack://tech-stack/./node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/html-flow.js","webpack://tech-stack/./node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/html-text.js","webpack://tech-stack/./node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/label-end.js","webpack://tech-stack/./node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/label-start-image.js","webpack://tech-stack/./node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/label-start-link.js","webpack://tech-stack/./node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/line-ending.js","webpack://tech-stack/./node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/list.js","webpack://tech-stack/./node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/setext-underline.js","webpack://tech-stack/./node_modules/.pnpm/micromark-core-commonmark@1.0.6/node_modules/micromark-core-commonmark/lib/thematic-break.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Code} Code\n * @typedef {import('micromark-util-types').Point} Point\n */\nimport {push, splice} from 'micromark-util-chunked'\nimport {classifyCharacter} from 'micromark-util-classify-character'\nimport {resolveAll} from 'micromark-util-resolve-all'\n\n/** @type {Construct} */\nexport const attention = {\n  name: 'attention',\n  tokenize: tokenizeAttention,\n  resolveAll: resolveAllAttention\n}\n/**\n * Take all events and resolve attention to emphasis or strong.\n *\n * @type {Resolver}\n */\n\nfunction resolveAllAttention(events, context) {\n  let index = -1\n  /** @type {number} */\n\n  let open\n  /** @type {Token} */\n\n  let group\n  /** @type {Token} */\n\n  let text\n  /** @type {Token} */\n\n  let openingSequence\n  /** @type {Token} */\n\n  let closingSequence\n  /** @type {number} */\n\n  let use\n  /** @type {Event[]} */\n\n  let nextEvents\n  /** @type {number} */\n\n  let offset // Walk through all events.\n  //\n  // Note: performance of this is fine on an mb of normal markdown, but it’s\n  // a bottleneck for malicious stuff.\n\n  while (++index < events.length) {\n    // Find a token that can close.\n    if (\n      events[index][0] === 'enter' &&\n      events[index][1].type === 'attentionSequence' &&\n      events[index][1]._close\n    ) {\n      open = index // Now walk back to find an opener.\n\n      while (open--) {\n        // Find a token that can open the closer.\n        if (\n          events[open][0] === 'exit' &&\n          events[open][1].type === 'attentionSequence' &&\n          events[open][1]._open && // If the markers are the same:\n          context.sliceSerialize(events[open][1]).charCodeAt(0) ===\n            context.sliceSerialize(events[index][1]).charCodeAt(0)\n        ) {\n          // If the opening can close or the closing can open,\n          // and the close size *is not* a multiple of three,\n          // but the sum of the opening and closing size *is* multiple of three,\n          // then don’t match.\n          if (\n            (events[open][1]._close || events[index][1]._open) &&\n            (events[index][1].end.offset - events[index][1].start.offset) % 3 &&\n            !(\n              (events[open][1].end.offset -\n                events[open][1].start.offset +\n                events[index][1].end.offset -\n                events[index][1].start.offset) %\n              3\n            )\n          ) {\n            continue\n          } // Number of markers to use from the sequence.\n\n          use =\n            events[open][1].end.offset - events[open][1].start.offset > 1 &&\n            events[index][1].end.offset - events[index][1].start.offset > 1\n              ? 2\n              : 1\n          const start = Object.assign({}, events[open][1].end)\n          const end = Object.assign({}, events[index][1].start)\n          movePoint(start, -use)\n          movePoint(end, use)\n          openingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start,\n            end: Object.assign({}, events[open][1].end)\n          }\n          closingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start: Object.assign({}, events[index][1].start),\n            end\n          }\n          text = {\n            type: use > 1 ? 'strongText' : 'emphasisText',\n            start: Object.assign({}, events[open][1].end),\n            end: Object.assign({}, events[index][1].start)\n          }\n          group = {\n            type: use > 1 ? 'strong' : 'emphasis',\n            start: Object.assign({}, openingSequence.start),\n            end: Object.assign({}, closingSequence.end)\n          }\n          events[open][1].end = Object.assign({}, openingSequence.start)\n          events[index][1].start = Object.assign({}, closingSequence.end)\n          nextEvents = [] // If there are more markers in the opening, add them before.\n\n          if (events[open][1].end.offset - events[open][1].start.offset) {\n            nextEvents = push(nextEvents, [\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context]\n            ])\n          } // Opening.\n\n          nextEvents = push(nextEvents, [\n            ['enter', group, context],\n            ['enter', openingSequence, context],\n            ['exit', openingSequence, context],\n            ['enter', text, context]\n          ]) // Between.\n\n          nextEvents = push(\n            nextEvents,\n            resolveAll(\n              context.parser.constructs.insideSpan.null,\n              events.slice(open + 1, index),\n              context\n            )\n          ) // Closing.\n\n          nextEvents = push(nextEvents, [\n            ['exit', text, context],\n            ['enter', closingSequence, context],\n            ['exit', closingSequence, context],\n            ['exit', group, context]\n          ]) // If there are more markers in the closing, add them after.\n\n          if (events[index][1].end.offset - events[index][1].start.offset) {\n            offset = 2\n            nextEvents = push(nextEvents, [\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context]\n            ])\n          } else {\n            offset = 0\n          }\n\n          splice(events, open - 1, index - open + 3, nextEvents)\n          index = open + nextEvents.length - offset - 2\n          break\n        }\n      }\n    }\n  } // Remove remaining sequences.\n\n  index = -1\n\n  while (++index < events.length) {\n    if (events[index][1].type === 'attentionSequence') {\n      events[index][1].type = 'data'\n    }\n  }\n\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeAttention(effects, ok) {\n  const attentionMarkers = this.parser.constructs.attentionMarkers.null\n  const previous = this.previous\n  const before = classifyCharacter(previous)\n  /** @type {NonNullable<Code>} */\n\n  let marker\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('attentionSequence')\n    marker = code\n    return sequence(code)\n  }\n  /** @type {State} */\n\n  function sequence(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return sequence\n    }\n\n    const token = effects.exit('attentionSequence')\n    const after = classifyCharacter(code)\n    const open =\n      !after || (after === 2 && before) || attentionMarkers.includes(code)\n    const close =\n      !before || (before === 2 && after) || attentionMarkers.includes(previous)\n    token._open = Boolean(marker === 42 ? open : open && (before || !close))\n    token._close = Boolean(marker === 42 ? close : close && (after || !open))\n    return ok(code)\n  }\n}\n/**\n * Move a point a bit.\n *\n * Note: `move` only works inside lines! It’s not possible to move past other\n * chunks (replacement characters, tabs, or line endings).\n *\n * @param {Point} point\n * @param {number} offset\n * @returns {void}\n */\n\nfunction movePoint(point, offset) {\n  point.column += offset\n  point.offset += offset\n  point._bufferIndex += offset\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  asciiAtext,\n  asciiControl\n} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const autolink = {\n  name: 'autolink',\n  tokenize: tokenizeAutolink\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeAutolink(effects, ok, nok) {\n  let size = 1\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('autolink')\n    effects.enter('autolinkMarker')\n    effects.consume(code)\n    effects.exit('autolinkMarker')\n    effects.enter('autolinkProtocol')\n    return open\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return schemeOrEmailAtext\n    }\n\n    return asciiAtext(code) ? emailAtext(code) : nok(code)\n  }\n  /** @type {State} */\n\n  function schemeOrEmailAtext(code) {\n    return code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)\n      ? schemeInsideOrEmailAtext(code)\n      : emailAtext(code)\n  }\n  /** @type {State} */\n\n  function schemeInsideOrEmailAtext(code) {\n    if (code === 58) {\n      effects.consume(code)\n      return urlInside\n    }\n\n    if (\n      (code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)) &&\n      size++ < 32\n    ) {\n      effects.consume(code)\n      return schemeInsideOrEmailAtext\n    }\n\n    return emailAtext(code)\n  }\n  /** @type {State} */\n\n  function urlInside(code) {\n    if (code === 62) {\n      effects.exit('autolinkProtocol')\n      return end(code)\n    }\n\n    if (code === null || code === 32 || code === 60 || asciiControl(code)) {\n      return nok(code)\n    }\n\n    effects.consume(code)\n    return urlInside\n  }\n  /** @type {State} */\n\n  function emailAtext(code) {\n    if (code === 64) {\n      effects.consume(code)\n      size = 0\n      return emailAtSignOrDot\n    }\n\n    if (asciiAtext(code)) {\n      effects.consume(code)\n      return emailAtext\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function emailAtSignOrDot(code) {\n    return asciiAlphanumeric(code) ? emailLabel(code) : nok(code)\n  }\n  /** @type {State} */\n\n  function emailLabel(code) {\n    if (code === 46) {\n      effects.consume(code)\n      size = 0\n      return emailAtSignOrDot\n    }\n\n    if (code === 62) {\n      // Exit, then change the type.\n      effects.exit('autolinkProtocol').type = 'autolinkEmail'\n      return end(code)\n    }\n\n    return emailValue(code)\n  }\n  /** @type {State} */\n\n  function emailValue(code) {\n    if ((code === 45 || asciiAlphanumeric(code)) && size++ < 63) {\n      effects.consume(code)\n      return code === 45 ? emailValue : emailLabel\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function end(code) {\n    effects.enter('autolinkMarker')\n    effects.consume(code)\n    effects.exit('autolinkMarker')\n    effects.exit('autolink')\n    return ok\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const blankLine = {\n  tokenize: tokenizeBlankLine,\n  partial: true\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeBlankLine(effects, ok, nok) {\n  return factorySpace(effects, afterWhitespace, 'linePrefix')\n  /** @type {State} */\n\n  function afterWhitespace(code) {\n    return code === null || markdownLineEnding(code) ? ok(code) : nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownSpace} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const blockQuote = {\n  name: 'blockQuote',\n  tokenize: tokenizeBlockQuoteStart,\n  continuation: {\n    tokenize: tokenizeBlockQuoteContinuation\n  },\n  exit\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeBlockQuoteStart(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (code === 62) {\n      const state = self.containerState\n\n      if (!state.open) {\n        effects.enter('blockQuote', {\n          _container: true\n        })\n        state.open = true\n      }\n\n      effects.enter('blockQuotePrefix')\n      effects.enter('blockQuoteMarker')\n      effects.consume(code)\n      effects.exit('blockQuoteMarker')\n      return after\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    if (markdownSpace(code)) {\n      effects.enter('blockQuotePrefixWhitespace')\n      effects.consume(code)\n      effects.exit('blockQuotePrefixWhitespace')\n      effects.exit('blockQuotePrefix')\n      return ok\n    }\n\n    effects.exit('blockQuotePrefix')\n    return ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeBlockQuoteContinuation(effects, ok, nok) {\n  return factorySpace(\n    effects,\n    effects.attempt(blockQuote, ok, nok),\n    'linePrefix',\n    this.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4\n  )\n}\n/** @type {Exiter} */\n\nfunction exit(effects) {\n  effects.exit('blockQuote')\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {asciiPunctuation} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const characterEscape = {\n  name: 'characterEscape',\n  tokenize: tokenizeCharacterEscape\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeCharacterEscape(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('characterEscape')\n    effects.enter('escapeMarker')\n    effects.consume(code)\n    effects.exit('escapeMarker')\n    return open\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (asciiPunctuation(code)) {\n      effects.enter('characterEscapeValue')\n      effects.consume(code)\n      effects.exit('characterEscapeValue')\n      effects.exit('characterEscape')\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {\n  asciiAlphanumeric,\n  asciiDigit,\n  asciiHexDigit\n} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const characterReference = {\n  name: 'characterReference',\n  tokenize: tokenizeCharacterReference\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeCharacterReference(effects, ok, nok) {\n  const self = this\n  let size = 0\n  /** @type {number} */\n\n  let max\n  /** @type {(code: Code) => code is number} */\n\n  let test\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('characterReference')\n    effects.enter('characterReferenceMarker')\n    effects.consume(code)\n    effects.exit('characterReferenceMarker')\n    return open\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (code === 35) {\n      effects.enter('characterReferenceMarkerNumeric')\n      effects.consume(code)\n      effects.exit('characterReferenceMarkerNumeric')\n      return numeric\n    }\n\n    effects.enter('characterReferenceValue')\n    max = 31\n    test = asciiAlphanumeric\n    return value(code)\n  }\n  /** @type {State} */\n\n  function numeric(code) {\n    if (code === 88 || code === 120) {\n      effects.enter('characterReferenceMarkerHexadecimal')\n      effects.consume(code)\n      effects.exit('characterReferenceMarkerHexadecimal')\n      effects.enter('characterReferenceValue')\n      max = 6\n      test = asciiHexDigit\n      return value\n    }\n\n    effects.enter('characterReferenceValue')\n    max = 7\n    test = asciiDigit\n    return value(code)\n  }\n  /** @type {State} */\n\n  function value(code) {\n    /** @type {Token} */\n    let token\n\n    if (code === 59 && size) {\n      token = effects.exit('characterReferenceValue')\n\n      if (\n        test === asciiAlphanumeric &&\n        !decodeNamedCharacterReference(self.sliceSerialize(token))\n      ) {\n        return nok(code)\n      }\n\n      effects.enter('characterReferenceMarker')\n      effects.consume(code)\n      effects.exit('characterReferenceMarker')\n      effects.exit('characterReference')\n      return ok\n    }\n\n    if (test(code) && size++ < max) {\n      effects.consume(code)\n      return value\n    }\n\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace\n} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const codeFenced = {\n  name: 'codeFenced',\n  tokenize: tokenizeCodeFenced,\n  concrete: true\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeCodeFenced(effects, ok, nok) {\n  const self = this\n  /** @type {Construct} */\n\n  const closingFenceConstruct = {\n    tokenize: tokenizeClosingFence,\n    partial: true\n  }\n  /** @type {Construct} */\n\n  const nonLazyLine = {\n    tokenize: tokenizeNonLazyLine,\n    partial: true\n  }\n  const tail = this.events[this.events.length - 1]\n  const initialPrefix =\n    tail && tail[1].type === 'linePrefix'\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let sizeOpen = 0\n  /** @type {NonNullable<Code>} */\n\n  let marker\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('codeFenced')\n    effects.enter('codeFencedFence')\n    effects.enter('codeFencedFenceSequence')\n    marker = code\n    return sequenceOpen(code)\n  }\n  /** @type {State} */\n\n  function sequenceOpen(code) {\n    if (code === marker) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n\n    effects.exit('codeFencedFenceSequence')\n    return sizeOpen < 3\n      ? nok(code)\n      : factorySpace(effects, infoOpen, 'whitespace')(code)\n  }\n  /** @type {State} */\n\n  function infoOpen(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return openAfter(code)\n    }\n\n    effects.enter('codeFencedFenceInfo')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return info(code)\n  }\n  /** @type {State} */\n\n  function info(code) {\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      effects.exit('chunkString')\n      effects.exit('codeFencedFenceInfo')\n      return factorySpace(effects, infoAfter, 'whitespace')(code)\n    }\n\n    if (code === 96 && code === marker) return nok(code)\n    effects.consume(code)\n    return info\n  }\n  /** @type {State} */\n\n  function infoAfter(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return openAfter(code)\n    }\n\n    effects.enter('codeFencedFenceMeta')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return meta(code)\n  }\n  /** @type {State} */\n\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      effects.exit('codeFencedFenceMeta')\n      return openAfter(code)\n    }\n\n    if (code === 96 && code === marker) return nok(code)\n    effects.consume(code)\n    return meta\n  }\n  /** @type {State} */\n\n  function openAfter(code) {\n    effects.exit('codeFencedFence')\n    return self.interrupt ? ok(code) : contentStart(code)\n  }\n  /** @type {State} */\n\n  function contentStart(code) {\n    if (code === null) {\n      return after(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(\n        nonLazyLine,\n        effects.attempt(\n          closingFenceConstruct,\n          after,\n          initialPrefix\n            ? factorySpace(\n                effects,\n                contentStart,\n                'linePrefix',\n                initialPrefix + 1\n              )\n            : contentStart\n        ),\n        after\n      )(code)\n    }\n\n    effects.enter('codeFlowValue')\n    return contentContinue(code)\n  }\n  /** @type {State} */\n\n  function contentContinue(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('codeFlowValue')\n      return contentStart(code)\n    }\n\n    effects.consume(code)\n    return contentContinue\n  }\n  /** @type {State} */\n\n  function after(code) {\n    effects.exit('codeFenced')\n    return ok(code)\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeNonLazyLine(effects, ok, nok) {\n    const self = this\n    return start\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return lineStart\n    }\n    /** @type {State} */\n\n    function lineStart(code) {\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n    }\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0\n    return factorySpace(\n      effects,\n      closingSequenceStart,\n      'linePrefix',\n      this.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : 4\n    )\n    /** @type {State} */\n\n    function closingSequenceStart(code) {\n      effects.enter('codeFencedFence')\n      effects.enter('codeFencedFenceSequence')\n      return closingSequence(code)\n    }\n    /** @type {State} */\n\n    function closingSequence(code) {\n      if (code === marker) {\n        effects.consume(code)\n        size++\n        return closingSequence\n      }\n\n      if (size < sizeOpen) return nok(code)\n      effects.exit('codeFencedFenceSequence')\n      return factorySpace(effects, closingSequenceEnd, 'whitespace')(code)\n    }\n    /** @type {State} */\n\n    function closingSequenceEnd(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('codeFencedFence')\n        return ok(code)\n      }\n\n      return nok(code)\n    }\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const codeIndented = {\n  name: 'codeIndented',\n  tokenize: tokenizeCodeIndented\n}\n/** @type {Construct} */\n\nconst indentedContent = {\n  tokenize: tokenizeIndentedContent,\n  partial: true\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeCodeIndented(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('codeIndented')\n    return factorySpace(effects, afterStartPrefix, 'linePrefix', 4 + 1)(code)\n  }\n  /** @type {State} */\n\n  function afterStartPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'linePrefix' &&\n      tail[2].sliceSerialize(tail[1], true).length >= 4\n      ? afterPrefix(code)\n      : nok(code)\n  }\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    if (code === null) {\n      return after(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(indentedContent, afterPrefix, after)(code)\n    }\n\n    effects.enter('codeFlowValue')\n    return content(code)\n  }\n  /** @type {State} */\n\n  function content(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('codeFlowValue')\n      return afterPrefix(code)\n    }\n\n    effects.consume(code)\n    return content\n  }\n  /** @type {State} */\n\n  function after(code) {\n    effects.exit('codeIndented')\n    return ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeIndentedContent(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    // If this is a lazy line, it can’t be code.\n    if (self.parser.lazy[self.now().line]) {\n      return nok(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return start\n    }\n\n    return factorySpace(effects, afterPrefix, 'linePrefix', 4 + 1)(code)\n  }\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'linePrefix' &&\n      tail[2].sliceSerialize(tail[1], true).length >= 4\n      ? ok(code)\n      : markdownLineEnding(code)\n      ? start(code)\n      : nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const codeText = {\n  name: 'codeText',\n  tokenize: tokenizeCodeText,\n  resolve: resolveCodeText,\n  previous\n}\n/** @type {Resolver} */\n\nfunction resolveCodeText(events) {\n  let tailExitIndex = events.length - 4\n  let headEnterIndex = 3\n  /** @type {number} */\n\n  let index\n  /** @type {number|undefined} */\n\n  let enter // If we start and end with an EOL or a space.\n\n  if (\n    (events[headEnterIndex][1].type === 'lineEnding' ||\n      events[headEnterIndex][1].type === 'space') &&\n    (events[tailExitIndex][1].type === 'lineEnding' ||\n      events[tailExitIndex][1].type === 'space')\n  ) {\n    index = headEnterIndex // And we have data.\n\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'codeTextData') {\n        // Then we have padding.\n        events[headEnterIndex][1].type = 'codeTextPadding'\n        events[tailExitIndex][1].type = 'codeTextPadding'\n        headEnterIndex += 2\n        tailExitIndex -= 2\n        break\n      }\n    }\n  } // Merge adjacent spaces and data.\n\n  index = headEnterIndex - 1\n  tailExitIndex++\n\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {\n        enter = index\n      }\n    } else if (\n      index === tailExitIndex ||\n      events[index][1].type === 'lineEnding'\n    ) {\n      events[enter][1].type = 'codeTextData'\n\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end\n        events.splice(enter + 2, index - enter - 2)\n        tailExitIndex -= index - enter - 2\n        index = enter + 2\n      }\n\n      enter = undefined\n    }\n  }\n\n  return events\n}\n/** @type {Previous} */\n\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return (\n    code !== 96 ||\n    this.events[this.events.length - 1][1].type === 'characterEscape'\n  )\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeCodeText(effects, ok, nok) {\n  const self = this\n  let sizeOpen = 0\n  /** @type {number} */\n\n  let size\n  /** @type {Token} */\n\n  let token\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('codeText')\n    effects.enter('codeTextSequence')\n    return openingSequence(code)\n  }\n  /** @type {State} */\n\n  function openingSequence(code) {\n    if (code === 96) {\n      effects.consume(code)\n      sizeOpen++\n      return openingSequence\n    }\n\n    effects.exit('codeTextSequence')\n    return gap(code)\n  }\n  /** @type {State} */\n\n  function gap(code) {\n    // EOF.\n    if (code === null) {\n      return nok(code)\n    } // Closing fence?\n    // Could also be data.\n\n    if (code === 96) {\n      token = effects.enter('codeTextSequence')\n      size = 0\n      return closingSequence(code)\n    } // Tabs don’t work, and virtual spaces don’t make sense.\n\n    if (code === 32) {\n      effects.enter('space')\n      effects.consume(code)\n      effects.exit('space')\n      return gap\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return gap\n    } // Data.\n\n    effects.enter('codeTextData')\n    return data(code)\n  } // In code.\n\n  /** @type {State} */\n\n  function data(code) {\n    if (\n      code === null ||\n      code === 32 ||\n      code === 96 ||\n      markdownLineEnding(code)\n    ) {\n      effects.exit('codeTextData')\n      return gap(code)\n    }\n\n    effects.consume(code)\n    return data\n  } // Closing fence.\n\n  /** @type {State} */\n\n  function closingSequence(code) {\n    // More.\n    if (code === 96) {\n      effects.consume(code)\n      size++\n      return closingSequence\n    } // Done!\n\n    if (size === sizeOpen) {\n      effects.exit('codeTextSequence')\n      effects.exit('codeText')\n      return ok(code)\n    } // More or less accents: mark as data.\n\n    token.type = 'codeTextData'\n    return data(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {subtokenize} from 'micromark-util-subtokenize'\n\n/**\n * No name because it must not be turned off.\n * @type {Construct}\n */\nexport const content = {\n  tokenize: tokenizeContent,\n  resolve: resolveContent\n}\n/** @type {Construct} */\n\nconst continuationConstruct = {\n  tokenize: tokenizeContinuation,\n  partial: true\n}\n/**\n * Content is transparent: it’s parsed right now. That way, definitions are also\n * parsed right now: before text in paragraphs (specifically, media) are parsed.\n *\n * @type {Resolver}\n */\n\nfunction resolveContent(events) {\n  subtokenize(events)\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeContent(effects, ok) {\n  /** @type {Token} */\n  let previous\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('content')\n    previous = effects.enter('chunkContent', {\n      contentType: 'content'\n    })\n    return data(code)\n  }\n  /** @type {State} */\n\n  function data(code) {\n    if (code === null) {\n      return contentEnd(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.check(\n        continuationConstruct,\n        contentContinue,\n        contentEnd\n      )(code)\n    } // Data.\n\n    effects.consume(code)\n    return data\n  }\n  /** @type {State} */\n\n  function contentEnd(code) {\n    effects.exit('chunkContent')\n    effects.exit('content')\n    return ok(code)\n  }\n  /** @type {State} */\n\n  function contentContinue(code) {\n    effects.consume(code)\n    effects.exit('chunkContent')\n    previous.next = effects.enter('chunkContent', {\n      contentType: 'content',\n      previous\n    })\n    previous = previous.next\n    return data\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeContinuation(effects, ok, nok) {\n  const self = this\n  return startLookahead\n  /** @type {State} */\n\n  function startLookahead(code) {\n    effects.exit('chunkContent')\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return factorySpace(effects, prefixed, 'linePrefix')\n  }\n  /** @type {State} */\n\n  function prefixed(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return nok(code)\n    }\n\n    const tail = self.events[self.events.length - 1]\n\n    if (\n      !self.parser.constructs.disable.null.includes('codeIndented') &&\n      tail &&\n      tail[1].type === 'linePrefix' &&\n      tail[2].sliceSerialize(tail[1], true).length >= 4\n    ) {\n      return ok(code)\n    }\n\n    return effects.interrupt(self.parser.constructs.flow, nok, ok)(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factorySpace} from 'micromark-factory-space'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace\n} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const definition = {\n  name: 'definition',\n  tokenize: tokenizeDefinition\n}\n/** @type {Construct} */\n\nconst titleConstruct = {\n  tokenize: tokenizeTitle,\n  partial: true\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeDefinition(effects, ok, nok) {\n  const self = this\n  /** @type {string} */\n\n  let identifier\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('definition')\n    return factoryLabel.call(\n      self,\n      effects,\n      labelAfter,\n      nok,\n      'definitionLabel',\n      'definitionLabelMarker',\n      'definitionLabelString'\n    )(code)\n  }\n  /** @type {State} */\n\n  function labelAfter(code) {\n    identifier = normalizeIdentifier(\n      self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n    )\n\n    if (code === 58) {\n      effects.enter('definitionMarker')\n      effects.consume(code)\n      effects.exit('definitionMarker') // Note: blank lines can’t exist in content.\n\n      return factoryWhitespace(\n        effects,\n        factoryDestination(\n          effects,\n          effects.attempt(\n            titleConstruct,\n            factorySpace(effects, after, 'whitespace'),\n            factorySpace(effects, after, 'whitespace')\n          ),\n          nok,\n          'definitionDestination',\n          'definitionDestinationLiteral',\n          'definitionDestinationLiteralMarker',\n          'definitionDestinationRaw',\n          'definitionDestinationString'\n        )\n      )\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('definition')\n\n      if (!self.parser.defined.includes(identifier)) {\n        self.parser.defined.push(identifier)\n      }\n\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeTitle(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, before)(code)\n      : nok(code)\n  }\n  /** @type {State} */\n\n  function before(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(\n        effects,\n        factorySpace(effects, after, 'whitespace'),\n        nok,\n        'definitionTitle',\n        'definitionTitleMarker',\n        'definitionTitleString'\n      )(code)\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    return code === null || markdownLineEnding(code) ? ok(code) : nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const hardBreakEscape = {\n  name: 'hardBreakEscape',\n  tokenize: tokenizeHardBreakEscape\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeHardBreakEscape(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('hardBreakEscape')\n    effects.enter('escapeMarker')\n    effects.consume(code)\n    return open\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (markdownLineEnding(code)) {\n      effects.exit('escapeMarker')\n      effects.exit('hardBreakEscape')\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {splice} from 'micromark-util-chunked'\n\n/** @type {Construct} */\nexport const headingAtx = {\n  name: 'headingAtx',\n  tokenize: tokenizeHeadingAtx,\n  resolve: resolveHeadingAtx\n}\n/** @type {Resolver} */\n\nfunction resolveHeadingAtx(events, context) {\n  let contentEnd = events.length - 2\n  let contentStart = 3\n  /** @type {Token} */\n\n  let content\n  /** @type {Token} */\n\n  let text // Prefix whitespace, part of the opening.\n\n  if (events[contentStart][1].type === 'whitespace') {\n    contentStart += 2\n  } // Suffix whitespace, part of the closing.\n\n  if (\n    contentEnd - 2 > contentStart &&\n    events[contentEnd][1].type === 'whitespace'\n  ) {\n    contentEnd -= 2\n  }\n\n  if (\n    events[contentEnd][1].type === 'atxHeadingSequence' &&\n    (contentStart === contentEnd - 1 ||\n      (contentEnd - 4 > contentStart &&\n        events[contentEnd - 2][1].type === 'whitespace'))\n  ) {\n    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4\n  }\n\n  if (contentEnd > contentStart) {\n    content = {\n      type: 'atxHeadingText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end\n    }\n    text = {\n      type: 'chunkText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end,\n      // @ts-expect-error Constants are fine to assign.\n      contentType: 'text'\n    }\n    splice(events, contentStart, contentEnd - contentStart + 1, [\n      ['enter', content, context],\n      ['enter', text, context],\n      ['exit', text, context],\n      ['exit', content, context]\n    ])\n  }\n\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeHeadingAtx(effects, ok, nok) {\n  const self = this\n  let size = 0\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('atxHeading')\n    effects.enter('atxHeadingSequence')\n    return fenceOpenInside(code)\n  }\n  /** @type {State} */\n\n  function fenceOpenInside(code) {\n    if (code === 35 && size++ < 6) {\n      effects.consume(code)\n      return fenceOpenInside\n    }\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingSequence')\n      return self.interrupt ? ok(code) : headingBreak(code)\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function headingBreak(code) {\n    if (code === 35) {\n      effects.enter('atxHeadingSequence')\n      return sequence(code)\n    }\n\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('atxHeading')\n      return ok(code)\n    }\n\n    if (markdownSpace(code)) {\n      return factorySpace(effects, headingBreak, 'whitespace')(code)\n    }\n\n    effects.enter('atxHeadingText')\n    return data(code)\n  }\n  /** @type {State} */\n\n  function sequence(code) {\n    if (code === 35) {\n      effects.consume(code)\n      return sequence\n    }\n\n    effects.exit('atxHeadingSequence')\n    return headingBreak(code)\n  }\n  /** @type {State} */\n\n  function data(code) {\n    if (code === null || code === 35 || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingText')\n      return headingBreak(code)\n    }\n\n    effects.consume(code)\n    return data\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {htmlBlockNames, htmlRawNames} from 'micromark-util-html-tag-name'\nimport {blankLine} from './blank-line.js'\n/** @type {Construct} */\n\nexport const htmlFlow = {\n  name: 'htmlFlow',\n  tokenize: tokenizeHtmlFlow,\n  resolveTo: resolveToHtmlFlow,\n  concrete: true\n}\n/** @type {Construct} */\n\nconst nextBlankConstruct = {\n  tokenize: tokenizeNextBlank,\n  partial: true\n}\n/** @type {Resolver} */\n\nfunction resolveToHtmlFlow(events) {\n  let index = events.length\n\n  while (index--) {\n    if (events[index][0] === 'enter' && events[index][1].type === 'htmlFlow') {\n      break\n    }\n  }\n\n  if (index > 1 && events[index - 2][1].type === 'linePrefix') {\n    // Add the prefix start to the HTML token.\n    events[index][1].start = events[index - 2][1].start // Add the prefix start to the HTML line token.\n\n    events[index + 1][1].start = events[index - 2][1].start // Remove the line prefix.\n\n    events.splice(index - 2, 2)\n  }\n\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeHtmlFlow(effects, ok, nok) {\n  const self = this\n  /** @type {number} */\n\n  let kind\n  /** @type {boolean} */\n\n  let startTag\n  /** @type {string} */\n\n  let buffer\n  /** @type {number} */\n\n  let index\n  /** @type {Code} */\n\n  let marker\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('htmlFlow')\n    effects.enter('htmlFlowData')\n    effects.consume(code)\n    return open\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (code === 33) {\n      effects.consume(code)\n      return declarationStart\n    }\n\n    if (code === 47) {\n      effects.consume(code)\n      return tagCloseStart\n    }\n\n    if (code === 63) {\n      effects.consume(code)\n      kind = 3 // While we’re in an instruction instead of a declaration, we’re on a `?`\n      // right now, so we do need to search for `>`, similar to declarations.\n\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      buffer = String.fromCharCode(code)\n      startTag = true\n      return tagName\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function declarationStart(code) {\n    if (code === 45) {\n      effects.consume(code)\n      kind = 2\n      return commentOpenInside\n    }\n\n    if (code === 91) {\n      effects.consume(code)\n      kind = 5\n      buffer = 'CDATA['\n      index = 0\n      return cdataOpenInside\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      kind = 4\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function commentOpenInside(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function cdataOpenInside(code) {\n    if (code === buffer.charCodeAt(index++)) {\n      effects.consume(code)\n      return index === buffer.length\n        ? self.interrupt\n          ? ok\n          : continuation\n        : cdataOpenInside\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      buffer = String.fromCharCode(code)\n      return tagName\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function tagName(code) {\n    if (\n      code === null ||\n      code === 47 ||\n      code === 62 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      if (\n        code !== 47 &&\n        startTag &&\n        htmlRawNames.includes(buffer.toLowerCase())\n      ) {\n        kind = 1\n        return self.interrupt ? ok(code) : continuation(code)\n      }\n\n      if (htmlBlockNames.includes(buffer.toLowerCase())) {\n        kind = 6\n\n        if (code === 47) {\n          effects.consume(code)\n          return basicSelfClosing\n        }\n\n        return self.interrupt ? ok(code) : continuation(code)\n      }\n\n      kind = 7 // Do not support complete HTML when interrupting\n\n      return self.interrupt && !self.parser.lazy[self.now().line]\n        ? nok(code)\n        : startTag\n        ? completeAttributeNameBefore(code)\n        : completeClosingTagAfter(code)\n    }\n\n    if (code === 45 || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      buffer += String.fromCharCode(code)\n      return tagName\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function basicSelfClosing(code) {\n    if (code === 62) {\n      effects.consume(code)\n      return self.interrupt ? ok : continuation\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function completeClosingTagAfter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeClosingTagAfter\n    }\n\n    return completeEnd(code)\n  }\n  /** @type {State} */\n\n  function completeAttributeNameBefore(code) {\n    if (code === 47) {\n      effects.consume(code)\n      return completeEnd\n    }\n\n    if (code === 58 || code === 95 || asciiAlpha(code)) {\n      effects.consume(code)\n      return completeAttributeName\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeNameBefore\n    }\n\n    return completeEnd(code)\n  }\n  /** @type {State} */\n\n  function completeAttributeName(code) {\n    if (\n      code === 45 ||\n      code === 46 ||\n      code === 58 ||\n      code === 95 ||\n      asciiAlphanumeric(code)\n    ) {\n      effects.consume(code)\n      return completeAttributeName\n    }\n\n    return completeAttributeNameAfter(code)\n  }\n  /** @type {State} */\n\n  function completeAttributeNameAfter(code) {\n    if (code === 61) {\n      effects.consume(code)\n      return completeAttributeValueBefore\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeNameAfter\n    }\n\n    return completeAttributeNameBefore(code)\n  }\n  /** @type {State} */\n\n  function completeAttributeValueBefore(code) {\n    if (\n      code === null ||\n      code === 60 ||\n      code === 61 ||\n      code === 62 ||\n      code === 96\n    ) {\n      return nok(code)\n    }\n\n    if (code === 34 || code === 39) {\n      effects.consume(code)\n      marker = code\n      return completeAttributeValueQuoted\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeValueBefore\n    }\n\n    marker = null\n    return completeAttributeValueUnquoted(code)\n  }\n  /** @type {State} */\n\n  function completeAttributeValueQuoted(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return nok(code)\n    }\n\n    if (code === marker) {\n      effects.consume(code)\n      return completeAttributeValueQuotedAfter\n    }\n\n    effects.consume(code)\n    return completeAttributeValueQuoted\n  }\n  /** @type {State} */\n\n  function completeAttributeValueUnquoted(code) {\n    if (\n      code === null ||\n      code === 34 ||\n      code === 39 ||\n      code === 60 ||\n      code === 61 ||\n      code === 62 ||\n      code === 96 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return completeAttributeNameAfter(code)\n    }\n\n    effects.consume(code)\n    return completeAttributeValueUnquoted\n  }\n  /** @type {State} */\n\n  function completeAttributeValueQuotedAfter(code) {\n    if (code === 47 || code === 62 || markdownSpace(code)) {\n      return completeAttributeNameBefore(code)\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function completeEnd(code) {\n    if (code === 62) {\n      effects.consume(code)\n      return completeAfter\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function completeAfter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAfter\n    }\n\n    return code === null || markdownLineEnding(code)\n      ? continuation(code)\n      : nok(code)\n  }\n  /** @type {State} */\n\n  function continuation(code) {\n    if (code === 45 && kind === 2) {\n      effects.consume(code)\n      return continuationCommentInside\n    }\n\n    if (code === 60 && kind === 1) {\n      effects.consume(code)\n      return continuationRawTagOpen\n    }\n\n    if (code === 62 && kind === 4) {\n      effects.consume(code)\n      return continuationClose\n    }\n\n    if (code === 63 && kind === 3) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    if (code === 93 && kind === 5) {\n      effects.consume(code)\n      return continuationCharacterDataInside\n    }\n\n    if (markdownLineEnding(code) && (kind === 6 || kind === 7)) {\n      return effects.check(\n        nextBlankConstruct,\n        continuationClose,\n        continuationAtLineEnding\n      )(code)\n    }\n\n    if (code === null || markdownLineEnding(code)) {\n      return continuationAtLineEnding(code)\n    }\n\n    effects.consume(code)\n    return continuation\n  }\n  /** @type {State} */\n\n  function continuationAtLineEnding(code) {\n    effects.exit('htmlFlowData')\n    return htmlContinueStart(code)\n  }\n  /** @type {State} */\n\n  function htmlContinueStart(code) {\n    if (code === null) {\n      return done(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(\n        {\n          tokenize: htmlLineEnd,\n          partial: true\n        },\n        htmlContinueStart,\n        done\n      )(code)\n    }\n\n    effects.enter('htmlFlowData')\n    return continuation(code)\n  }\n  /** @type {Tokenizer} */\n\n  function htmlLineEnd(effects, ok, nok) {\n    return start\n    /** @type {State} */\n\n    function start(code) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return lineStart\n    }\n    /** @type {State} */\n\n    function lineStart(code) {\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n    }\n  }\n  /** @type {State} */\n\n  function continuationCommentInside(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n  /** @type {State} */\n\n  function continuationRawTagOpen(code) {\n    if (code === 47) {\n      effects.consume(code)\n      buffer = ''\n      return continuationRawEndTag\n    }\n\n    return continuation(code)\n  }\n  /** @type {State} */\n\n  function continuationRawEndTag(code) {\n    if (code === 62 && htmlRawNames.includes(buffer.toLowerCase())) {\n      effects.consume(code)\n      return continuationClose\n    }\n\n    if (asciiAlpha(code) && buffer.length < 8) {\n      effects.consume(code)\n      buffer += String.fromCharCode(code)\n      return continuationRawEndTag\n    }\n\n    return continuation(code)\n  }\n  /** @type {State} */\n\n  function continuationCharacterDataInside(code) {\n    if (code === 93) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n  /** @type {State} */\n\n  function continuationDeclarationInside(code) {\n    if (code === 62) {\n      effects.consume(code)\n      return continuationClose\n    } // More dashes.\n\n    if (code === 45 && kind === 2) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n  /** @type {State} */\n\n  function continuationClose(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('htmlFlowData')\n      return done(code)\n    }\n\n    effects.consume(code)\n    return continuationClose\n  }\n  /** @type {State} */\n\n  function done(code) {\n    effects.exit('htmlFlow')\n    return ok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeNextBlank(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.exit('htmlFlowData')\n    effects.enter('lineEndingBlank')\n    effects.consume(code)\n    effects.exit('lineEndingBlank')\n    return effects.attempt(blankLine, ok, nok)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const htmlText = {\n  name: 'htmlText',\n  tokenize: tokenizeHtmlText\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeHtmlText(effects, ok, nok) {\n  const self = this\n  /** @type {NonNullable<Code>|undefined} */\n\n  let marker\n  /** @type {string} */\n\n  let buffer\n  /** @type {number} */\n\n  let index\n  /** @type {State} */\n\n  let returnState\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('htmlText')\n    effects.enter('htmlTextData')\n    effects.consume(code)\n    return open\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (code === 33) {\n      effects.consume(code)\n      return declarationOpen\n    }\n\n    if (code === 47) {\n      effects.consume(code)\n      return tagCloseStart\n    }\n\n    if (code === 63) {\n      effects.consume(code)\n      return instruction\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return tagOpen\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function declarationOpen(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return commentOpen\n    }\n\n    if (code === 91) {\n      effects.consume(code)\n      buffer = 'CDATA['\n      index = 0\n      return cdataOpen\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return declaration\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function commentOpen(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return commentStart\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function commentStart(code) {\n    if (code === null || code === 62) {\n      return nok(code)\n    }\n\n    if (code === 45) {\n      effects.consume(code)\n      return commentStartDash\n    }\n\n    return comment(code)\n  }\n  /** @type {State} */\n\n  function commentStartDash(code) {\n    if (code === null || code === 62) {\n      return nok(code)\n    }\n\n    return comment(code)\n  }\n  /** @type {State} */\n\n  function comment(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    if (code === 45) {\n      effects.consume(code)\n      return commentClose\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = comment\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return comment\n  }\n  /** @type {State} */\n\n  function commentClose(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return end\n    }\n\n    return comment(code)\n  }\n  /** @type {State} */\n\n  function cdataOpen(code) {\n    if (code === buffer.charCodeAt(index++)) {\n      effects.consume(code)\n      return index === buffer.length ? cdata : cdataOpen\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function cdata(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    if (code === 93) {\n      effects.consume(code)\n      return cdataClose\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = cdata\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return cdata\n  }\n  /** @type {State} */\n\n  function cdataClose(code) {\n    if (code === 93) {\n      effects.consume(code)\n      return cdataEnd\n    }\n\n    return cdata(code)\n  }\n  /** @type {State} */\n\n  function cdataEnd(code) {\n    if (code === 62) {\n      return end(code)\n    }\n\n    if (code === 93) {\n      effects.consume(code)\n      return cdataEnd\n    }\n\n    return cdata(code)\n  }\n  /** @type {State} */\n\n  function declaration(code) {\n    if (code === null || code === 62) {\n      return end(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = declaration\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return declaration\n  }\n  /** @type {State} */\n\n  function instruction(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    if (code === 63) {\n      effects.consume(code)\n      return instructionClose\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = instruction\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return instruction\n  }\n  /** @type {State} */\n\n  function instructionClose(code) {\n    return code === 62 ? end(code) : instruction(code)\n  }\n  /** @type {State} */\n\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return tagClose\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function tagClose(code) {\n    if (code === 45 || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      return tagClose\n    }\n\n    return tagCloseBetween(code)\n  }\n  /** @type {State} */\n\n  function tagCloseBetween(code) {\n    if (markdownLineEnding(code)) {\n      returnState = tagCloseBetween\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagCloseBetween\n    }\n\n    return end(code)\n  }\n  /** @type {State} */\n\n  function tagOpen(code) {\n    if (code === 45 || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      return tagOpen\n    }\n\n    if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code)\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function tagOpenBetween(code) {\n    if (code === 47) {\n      effects.consume(code)\n      return end\n    }\n\n    if (code === 58 || code === 95 || asciiAlpha(code)) {\n      effects.consume(code)\n      return tagOpenAttributeName\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenBetween\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenBetween\n    }\n\n    return end(code)\n  }\n  /** @type {State} */\n\n  function tagOpenAttributeName(code) {\n    if (\n      code === 45 ||\n      code === 46 ||\n      code === 58 ||\n      code === 95 ||\n      asciiAlphanumeric(code)\n    ) {\n      effects.consume(code)\n      return tagOpenAttributeName\n    }\n\n    return tagOpenAttributeNameAfter(code)\n  }\n  /** @type {State} */\n\n  function tagOpenAttributeNameAfter(code) {\n    if (code === 61) {\n      effects.consume(code)\n      return tagOpenAttributeValueBefore\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeNameAfter\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenAttributeNameAfter\n    }\n\n    return tagOpenBetween(code)\n  }\n  /** @type {State} */\n\n  function tagOpenAttributeValueBefore(code) {\n    if (\n      code === null ||\n      code === 60 ||\n      code === 61 ||\n      code === 62 ||\n      code === 96\n    ) {\n      return nok(code)\n    }\n\n    if (code === 34 || code === 39) {\n      effects.consume(code)\n      marker = code\n      return tagOpenAttributeValueQuoted\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueBefore\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenAttributeValueBefore\n    }\n\n    effects.consume(code)\n    marker = undefined\n    return tagOpenAttributeValueUnquoted\n  }\n  /** @type {State} */\n\n  function tagOpenAttributeValueQuoted(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return tagOpenAttributeValueQuotedAfter\n    }\n\n    if (code === null) {\n      return nok(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueQuoted\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return tagOpenAttributeValueQuoted\n  }\n  /** @type {State} */\n\n  function tagOpenAttributeValueQuotedAfter(code) {\n    if (code === 62 || code === 47 || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code)\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function tagOpenAttributeValueUnquoted(code) {\n    if (\n      code === null ||\n      code === 34 ||\n      code === 39 ||\n      code === 60 ||\n      code === 61 ||\n      code === 96\n    ) {\n      return nok(code)\n    }\n\n    if (code === 62 || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code)\n    }\n\n    effects.consume(code)\n    return tagOpenAttributeValueUnquoted\n  } // We can’t have blank lines in content, so no need to worry about empty\n  // tokens.\n\n  /** @type {State} */\n\n  function atLineEnding(code) {\n    effects.exit('htmlTextData')\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return factorySpace(\n      effects,\n      afterPrefix,\n      'linePrefix',\n      self.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : 4\n    )\n  }\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    effects.enter('htmlTextData')\n    return returnState(code)\n  }\n  /** @type {State} */\n\n  function end(code) {\n    if (code === 62) {\n      effects.consume(code)\n      effects.exit('htmlTextData')\n      effects.exit('htmlText')\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\nimport {push, splice} from 'micromark-util-chunked'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {resolveAll} from 'micromark-util-resolve-all'\n\n/** @type {Construct} */\nexport const labelEnd = {\n  name: 'labelEnd',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n}\n/** @type {Construct} */\n\nconst resourceConstruct = {\n  tokenize: tokenizeResource\n}\n/** @type {Construct} */\n\nconst fullReferenceConstruct = {\n  tokenize: tokenizeFullReference\n}\n/** @type {Construct} */\n\nconst collapsedReferenceConstruct = {\n  tokenize: tokenizeCollapsedReference\n}\n/** @type {Resolver} */\n\nfunction resolveAllLabelEnd(events) {\n  let index = -1\n  /** @type {Token} */\n\n  let token\n\n  while (++index < events.length) {\n    token = events[index][1]\n\n    if (\n      token.type === 'labelImage' ||\n      token.type === 'labelLink' ||\n      token.type === 'labelEnd'\n    ) {\n      // Remove the marker.\n      events.splice(index + 1, token.type === 'labelImage' ? 4 : 2)\n      token.type = 'data'\n      index++\n    }\n  }\n\n  return events\n}\n/** @type {Resolver} */\n\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length\n  let offset = 0\n  /** @type {Token} */\n\n  let token\n  /** @type {number|undefined} */\n\n  let open\n  /** @type {number|undefined} */\n\n  let close\n  /** @type {Event[]} */\n\n  let media // Find an opening.\n\n  while (index--) {\n    token = events[index][1]\n\n    if (open) {\n      // If we see another link, or inactive link label, we’ve been here before.\n      if (\n        token.type === 'link' ||\n        (token.type === 'labelLink' && token._inactive)\n      ) {\n        break\n      } // Mark other link openings as inactive, as we can’t have links in\n      // links.\n\n      if (events[index][0] === 'enter' && token.type === 'labelLink') {\n        token._inactive = true\n      }\n    } else if (close) {\n      if (\n        events[index][0] === 'enter' &&\n        (token.type === 'labelImage' || token.type === 'labelLink') &&\n        !token._balanced\n      ) {\n        open = index\n\n        if (token.type !== 'labelLink') {\n          offset = 2\n          break\n        }\n      }\n    } else if (token.type === 'labelEnd') {\n      close = index\n    }\n  }\n\n  const group = {\n    type: events[open][1].type === 'labelLink' ? 'link' : 'image',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n  const label = {\n    type: 'label',\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[close][1].end)\n  }\n  const text = {\n    type: 'labelText',\n    start: Object.assign({}, events[open + offset + 2][1].end),\n    end: Object.assign({}, events[close - 2][1].start)\n  }\n  media = [\n    ['enter', group, context],\n    ['enter', label, context]\n  ] // Opening marker.\n\n  media = push(media, events.slice(open + 1, open + offset + 3)) // Text open.\n\n  media = push(media, [['enter', text, context]]) // Between.\n\n  media = push(\n    media,\n    resolveAll(\n      context.parser.constructs.insideSpan.null,\n      events.slice(open + offset + 4, close - 3),\n      context\n    )\n  ) // Text close, marker close, label close.\n\n  media = push(media, [\n    ['exit', text, context],\n    events[close - 2],\n    events[close - 1],\n    ['exit', label, context]\n  ]) // Reference, resource, or so.\n\n  media = push(media, events.slice(close + 1)) // Media close.\n\n  media = push(media, [['exit', group, context]])\n  splice(events, open, events.length, media)\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Token} */\n\n  let labelStart\n  /** @type {boolean} */\n\n  let defined // Find an opening.\n\n  while (index--) {\n    if (\n      (self.events[index][1].type === 'labelImage' ||\n        self.events[index][1].type === 'labelLink') &&\n      !self.events[index][1]._balanced\n    ) {\n      labelStart = self.events[index][1]\n      break\n    }\n  }\n\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (!labelStart) {\n      return nok(code)\n    } // It’s a balanced bracket, but contains a link.\n\n    if (labelStart._inactive) return balanced(code)\n    defined = self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize({\n          start: labelStart.end,\n          end: self.now()\n        })\n      )\n    )\n    effects.enter('labelEnd')\n    effects.enter('labelMarker')\n    effects.consume(code)\n    effects.exit('labelMarker')\n    effects.exit('labelEnd')\n    return afterLabelEnd\n  }\n  /** @type {State} */\n\n  function afterLabelEnd(code) {\n    // Resource: `[asd](fgh)`.\n    if (code === 40) {\n      return effects.attempt(\n        resourceConstruct,\n        ok,\n        defined ? ok : balanced\n      )(code)\n    } // Collapsed (`[asd][]`) or full (`[asd][fgh]`) reference?\n\n    if (code === 91) {\n      return effects.attempt(\n        fullReferenceConstruct,\n        ok,\n        defined\n          ? effects.attempt(collapsedReferenceConstruct, ok, balanced)\n          : balanced\n      )(code)\n    } // Shortcut reference: `[asd]`?\n\n    return defined ? ok(code) : balanced(code)\n  }\n  /** @type {State} */\n\n  function balanced(code) {\n    labelStart._balanced = true\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeResource(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('resource')\n    effects.enter('resourceMarker')\n    effects.consume(code)\n    effects.exit('resourceMarker')\n    return factoryWhitespace(effects, open)\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (code === 41) {\n      return end(code)\n    }\n\n    return factoryDestination(\n      effects,\n      destinationAfter,\n      nok,\n      'resourceDestination',\n      'resourceDestinationLiteral',\n      'resourceDestinationLiteralMarker',\n      'resourceDestinationRaw',\n      'resourceDestinationString',\n      32\n    )(code)\n  }\n  /** @type {State} */\n\n  function destinationAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, between)(code)\n      : end(code)\n  }\n  /** @type {State} */\n\n  function between(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(\n        effects,\n        factoryWhitespace(effects, end),\n        nok,\n        'resourceTitle',\n        'resourceTitleMarker',\n        'resourceTitleString'\n      )(code)\n    }\n\n    return end(code)\n  }\n  /** @type {State} */\n\n  function end(code) {\n    if (code === 41) {\n      effects.enter('resourceMarker')\n      effects.consume(code)\n      effects.exit('resourceMarker')\n      effects.exit('resource')\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeFullReference(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    return factoryLabel.call(\n      self,\n      effects,\n      afterLabel,\n      nok,\n      'reference',\n      'referenceMarker',\n      'referenceString'\n    )(code)\n  }\n  /** @type {State} */\n\n  function afterLabel(code) {\n    return self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n      )\n    )\n      ? ok(code)\n      : nok(code)\n  }\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeCollapsedReference(effects, ok, nok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('reference')\n    effects.enter('referenceMarker')\n    effects.consume(code)\n    effects.exit('referenceMarker')\n    return open\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (code === 93) {\n      effects.enter('referenceMarker')\n      effects.consume(code)\n      effects.exit('referenceMarker')\n      effects.exit('reference')\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {labelEnd} from './label-end.js'\n/** @type {Construct} */\n\nexport const labelStartImage = {\n  name: 'labelStartImage',\n  tokenize: tokenizeLabelStartImage,\n  resolveAll: labelEnd.resolveAll\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeLabelStartImage(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('labelImage')\n    effects.enter('labelImageMarker')\n    effects.consume(code)\n    effects.exit('labelImageMarker')\n    return open\n  }\n  /** @type {State} */\n\n  function open(code) {\n    if (code === 91) {\n      effects.enter('labelMarker')\n      effects.consume(code)\n      effects.exit('labelMarker')\n      effects.exit('labelImage')\n      return after\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function after(code) {\n    /* To do: remove in the future once we’ve switched from\n     * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\n     * which doesn’t need this */\n\n    /* Hidden footnotes hook */\n\n    /* c8 ignore next 3 */\n    return code === 94 && '_hiddenFootnoteSupport' in self.parser.constructs\n      ? nok(code)\n      : ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {labelEnd} from './label-end.js'\n/** @type {Construct} */\n\nexport const labelStartLink = {\n  name: 'labelStartLink',\n  tokenize: tokenizeLabelStartLink,\n  resolveAll: labelEnd.resolveAll\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeLabelStartLink(effects, ok, nok) {\n  const self = this\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('labelLink')\n    effects.enter('labelMarker')\n    effects.consume(code)\n    effects.exit('labelMarker')\n    effects.exit('labelLink')\n    return after\n  }\n  /** @type {State} */\n\n  function after(code) {\n    /* To do: remove in the future once we’ve switched from\n     * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\n     * which doesn’t need this */\n\n    /* Hidden footnotes hook. */\n\n    /* c8 ignore next 3 */\n    return code === 94 && '_hiddenFootnoteSupport' in self.parser.constructs\n      ? nok(code)\n      : ok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const lineEnding = {\n  name: 'lineEnding',\n  tokenize: tokenizeLineEnding\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeLineEnding(effects, ok) {\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return factorySpace(effects, ok, 'linePrefix')\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\n\n/**\n * @typedef {Record<string, unknown> & {marker: Code, type: string, size: number}} ListContainerState\n * @typedef {TokenizeContext & {containerState: ListContainerState}} TokenizeContextWithState\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {asciiDigit, markdownSpace} from 'micromark-util-character'\nimport {blankLine} from './blank-line.js'\nimport {thematicBreak} from './thematic-break.js'\n/** @type {Construct} */\n\nexport const list = {\n  name: 'list',\n  tokenize: tokenizeListStart,\n  continuation: {\n    tokenize: tokenizeListContinuation\n  },\n  exit: tokenizeListEnd\n}\n/** @type {Construct} */\n\nconst listItemPrefixWhitespaceConstruct = {\n  tokenize: tokenizeListItemPrefixWhitespace,\n  partial: true\n}\n/** @type {Construct} */\n\nconst indentConstruct = {\n  tokenize: tokenizeIndent,\n  partial: true\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\nfunction tokenizeListStart(effects, ok, nok) {\n  const self = this\n  const tail = self.events[self.events.length - 1]\n  let initialSize =\n    tail && tail[1].type === 'linePrefix'\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let size = 0\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    const kind =\n      self.containerState.type ||\n      (code === 42 || code === 43 || code === 45\n        ? 'listUnordered'\n        : 'listOrdered')\n\n    if (\n      kind === 'listUnordered'\n        ? !self.containerState.marker || code === self.containerState.marker\n        : asciiDigit(code)\n    ) {\n      if (!self.containerState.type) {\n        self.containerState.type = kind\n        effects.enter(kind, {\n          _container: true\n        })\n      }\n\n      if (kind === 'listUnordered') {\n        effects.enter('listItemPrefix')\n        return code === 42 || code === 45\n          ? effects.check(thematicBreak, nok, atMarker)(code)\n          : atMarker(code)\n      }\n\n      if (!self.interrupt || code === 49) {\n        effects.enter('listItemPrefix')\n        effects.enter('listItemValue')\n        return inside(code)\n      }\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function inside(code) {\n    if (asciiDigit(code) && ++size < 10) {\n      effects.consume(code)\n      return inside\n    }\n\n    if (\n      (!self.interrupt || size < 2) &&\n      (self.containerState.marker\n        ? code === self.containerState.marker\n        : code === 41 || code === 46)\n    ) {\n      effects.exit('listItemValue')\n      return atMarker(code)\n    }\n\n    return nok(code)\n  }\n  /**\n   * @type {State}\n   **/\n\n  function atMarker(code) {\n    effects.enter('listItemMarker')\n    effects.consume(code)\n    effects.exit('listItemMarker')\n    self.containerState.marker = self.containerState.marker || code\n    return effects.check(\n      blankLine, // Can’t be empty when interrupting.\n      self.interrupt ? nok : onBlank,\n      effects.attempt(\n        listItemPrefixWhitespaceConstruct,\n        endOfPrefix,\n        otherPrefix\n      )\n    )\n  }\n  /** @type {State} */\n\n  function onBlank(code) {\n    self.containerState.initialBlankLine = true\n    initialSize++\n    return endOfPrefix(code)\n  }\n  /** @type {State} */\n\n  function otherPrefix(code) {\n    if (markdownSpace(code)) {\n      effects.enter('listItemPrefixWhitespace')\n      effects.consume(code)\n      effects.exit('listItemPrefixWhitespace')\n      return endOfPrefix\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function endOfPrefix(code) {\n    self.containerState.size =\n      initialSize +\n      self.sliceSerialize(effects.exit('listItemPrefix'), true).length\n    return ok(code)\n  }\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\nfunction tokenizeListContinuation(effects, ok, nok) {\n  const self = this\n  self.containerState._closeFlow = undefined\n  return effects.check(blankLine, onBlank, notBlank)\n  /** @type {State} */\n\n  function onBlank(code) {\n    self.containerState.furtherBlankLines =\n      self.containerState.furtherBlankLines ||\n      self.containerState.initialBlankLine // We have a blank line.\n    // Still, try to consume at most the items size.\n\n    return factorySpace(\n      effects,\n      ok,\n      'listItemIndent',\n      self.containerState.size + 1\n    )(code)\n  }\n  /** @type {State} */\n\n  function notBlank(code) {\n    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {\n      self.containerState.furtherBlankLines = undefined\n      self.containerState.initialBlankLine = undefined\n      return notInCurrentItem(code)\n    }\n\n    self.containerState.furtherBlankLines = undefined\n    self.containerState.initialBlankLine = undefined\n    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code)\n  }\n  /** @type {State} */\n\n  function notInCurrentItem(code) {\n    // While we do continue, we signal that the flow should be closed.\n    self.containerState._closeFlow = true // As we’re closing flow, we’re no longer interrupting.\n\n    self.interrupt = undefined\n    return factorySpace(\n      effects,\n      effects.attempt(list, ok, nok),\n      'linePrefix',\n      self.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : 4\n    )(code)\n  }\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'listItemIndent',\n    self.containerState.size + 1\n  )\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'listItemIndent' &&\n      tail[2].sliceSerialize(tail[1], true).length === self.containerState.size\n      ? ok(code)\n      : nok(code)\n  }\n}\n/**\n * @type {Exiter}\n * @this {TokenizeContextWithState}\n */\n\nfunction tokenizeListEnd(effects) {\n  effects.exit(this.containerState.type)\n}\n/**\n * @type {Tokenizer}\n * @this {TokenizeContextWithState}\n */\n\nfunction tokenizeListItemPrefixWhitespace(effects, ok, nok) {\n  const self = this\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'listItemPrefixWhitespace',\n    self.parser.constructs.disable.null.includes('codeIndented')\n      ? undefined\n      : 4 + 1\n  )\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return !markdownSpace(code) &&\n      tail &&\n      tail[1].type === 'listItemPrefixWhitespace'\n      ? ok(code)\n      : nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const setextUnderline = {\n  name: 'setextUnderline',\n  tokenize: tokenizeSetextUnderline,\n  resolveTo: resolveToSetextUnderline\n}\n/** @type {Resolver} */\n\nfunction resolveToSetextUnderline(events, context) {\n  let index = events.length\n  /** @type {number|undefined} */\n\n  let content\n  /** @type {number|undefined} */\n\n  let text\n  /** @type {number|undefined} */\n\n  let definition // Find the opening of the content.\n  // It’ll always exist: we don’t tokenize if it isn’t there.\n\n  while (index--) {\n    if (events[index][0] === 'enter') {\n      if (events[index][1].type === 'content') {\n        content = index\n        break\n      }\n\n      if (events[index][1].type === 'paragraph') {\n        text = index\n      }\n    } // Exit\n    else {\n      if (events[index][1].type === 'content') {\n        // Remove the content end (if needed we’ll add it later)\n        events.splice(index, 1)\n      }\n\n      if (!definition && events[index][1].type === 'definition') {\n        definition = index\n      }\n    }\n  }\n\n  const heading = {\n    type: 'setextHeading',\n    start: Object.assign({}, events[text][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  } // Change the paragraph to setext heading text.\n\n  events[text][1].type = 'setextHeadingText' // If we have definitions in the content, we’ll keep on having content,\n  // but we need move it.\n\n  if (definition) {\n    events.splice(text, 0, ['enter', heading, context])\n    events.splice(definition + 1, 0, ['exit', events[content][1], context])\n    events[content][1].end = Object.assign({}, events[definition][1].end)\n  } else {\n    events[content][1] = heading\n  } // Add the heading exit at the end.\n\n  events.push(['exit', heading, context])\n  return events\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeSetextUnderline(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {NonNullable<Code>} */\n\n  let marker\n  /** @type {boolean} */\n\n  let paragraph // Find an opening.\n\n  while (index--) {\n    // Skip enter/exit of line ending, line prefix, and content.\n    // We can now either have a definition or a paragraph.\n    if (\n      self.events[index][1].type !== 'lineEnding' &&\n      self.events[index][1].type !== 'linePrefix' &&\n      self.events[index][1].type !== 'content'\n    ) {\n      paragraph = self.events[index][1].type === 'paragraph'\n      break\n    }\n  }\n\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {\n      effects.enter('setextHeadingLine')\n      effects.enter('setextHeadingLineSequence')\n      marker = code\n      return closingSequence(code)\n    }\n\n    return nok(code)\n  }\n  /** @type {State} */\n\n  function closingSequence(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return closingSequence\n    }\n\n    effects.exit('setextHeadingLineSequence')\n    return factorySpace(effects, closingSequenceEnd, 'lineSuffix')(code)\n  }\n  /** @type {State} */\n\n  function closingSequenceEnd(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('setextHeadingLine')\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n","/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\n\n/** @type {Construct} */\nexport const thematicBreak = {\n  name: 'thematicBreak',\n  tokenize: tokenizeThematicBreak\n}\n/** @type {Tokenizer} */\n\nfunction tokenizeThematicBreak(effects, ok, nok) {\n  let size = 0\n  /** @type {NonNullable<Code>} */\n\n  let marker\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    effects.enter('thematicBreak')\n    marker = code\n    return atBreak(code)\n  }\n  /** @type {State} */\n\n  function atBreak(code) {\n    if (code === marker) {\n      effects.enter('thematicBreakSequence')\n      return sequence(code)\n    }\n\n    if (markdownSpace(code)) {\n      return factorySpace(effects, atBreak, 'whitespace')(code)\n    }\n\n    if (size < 3 || (code !== null && !markdownLineEnding(code))) {\n      return nok(code)\n    }\n\n    effects.exit('thematicBreak')\n    return ok(code)\n  }\n  /** @type {State} */\n\n  function sequence(code) {\n    if (code === marker) {\n      effects.consume(code)\n      size++\n      return sequence\n    }\n\n    effects.exit('thematicBreakSequence')\n    return atBreak(code)\n  }\n}\n"],"names":["attention","name","tokenize","effects","ok","attentionMarkers","this","parser","constructs","null","previous","before","marker","code","enter","sequence","consume","token","exit","after","open","includes","close","_open","Boolean","_close","resolveAll","events","context","group","text","openingSequence","closingSequence","use","nextEvents","offset","index","length","type","sliceSerialize","charCodeAt","end","start","Object","assign","movePoint","insideSpan","slice","point","column","_bufferIndex","autolink","nok","size","schemeOrEmailAtext","emailAtext","schemeInsideOrEmailAtext","urlInside","emailAtSignOrDot","emailLabel","emailValue","blankLine","f","partial","blockQuote","self","state","containerState","_container","continuation","attempt","disable","undefined","characterEscape","characterReference","max","test","numeric","value","codeFenced","closingFenceConstruct","sizeOpen","closingSequenceEnd","nonLazyLine","lineStart","lazy","now","line","tail","initialPrefix","sequenceOpen","infoOpen","openAfter","contentType","info","infoAfter","meta","interrupt","contentStart","contentContinue","concrete","codeIndented","afterStartPrefix","afterPrefix","indentedContent","content","codeText","gap","data","resolve","tailExitIndex","headEnterIndex","splice","contentEnd","check","continuationConstruct","next","prefixed","flow","definition","identifier","labelAfter","titleConstruct","defined","push","hardBreakEscape","headingAtx","fenceOpenInside","headingBreak","htmlFlow","kind","startTag","buffer","declarationStart","tagCloseStart","continuationDeclarationInside","String","fromCharCode","tagName","commentOpenInside","cdataOpenInside","toLowerCase","basicSelfClosing","completeAttributeNameBefore","completeClosingTagAfter","completeEnd","completeAttributeName","completeAttributeNameAfter","completeAttributeValueBefore","completeAttributeValueQuoted","completeAttributeValueUnquoted","completeAttributeValueQuotedAfter","completeAfter","continuationCommentInside","continuationRawTagOpen","continuationClose","continuationCharacterDataInside","continuationAtLineEnding","nextBlankConstruct","htmlContinueStart","done","htmlLineEnd","continuationRawEndTag","resolveTo","htmlText","returnState","declarationOpen","instruction","tagOpen","commentOpen","cdataOpen","declaration","commentStart","commentStartDash","comment","commentClose","atLineEnding","cdata","cdataClose","cdataEnd","instructionClose","tagClose","tagCloseBetween","tagOpenBetween","tagOpenAttributeName","tagOpenAttributeNameAfter","tagOpenAttributeValueBefore","tagOpenAttributeValueQuoted","tagOpenAttributeValueUnquoted","tagOpenAttributeValueQuotedAfter","labelEnd","labelStart","_balanced","_inactive","balanced","afterLabelEnd","resourceConstruct","fullReferenceConstruct","collapsedReferenceConstruct","media","label","destinationAfter","between","afterLabel","labelStartImage","labelStartLink","lineEnding","list","initialSize","atMarker","inside","onBlank","listItemPrefixWhitespaceConstruct","endOfPrefix","otherPrefix","initialBlankLine","_closeFlow","furtherBlankLines","notInCurrentItem","indentConstruct","setextUnderline","paragraph","heading","thematicBreak","atBreak"],"sourceRoot":""}