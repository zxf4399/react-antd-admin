{"version":3,"file":".pnpm/vfile@5.3.2/node_modules/vfile/lib.78cc6e7895d1f72bac99.js","mappings":"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","sources":["webpack://react-antd-admin/./node_modules/.pnpm/vfile@5.3.2/node_modules/vfile/lib/minpath.browser.js","webpack://react-antd-admin/./node_modules/.pnpm/vfile@5.3.2/node_modules/vfile/lib/minproc.browser.js","webpack://react-antd-admin/./node_modules/.pnpm/vfile@5.3.2/node_modules/vfile/lib/minurl.shared.js","webpack://react-antd-admin/./node_modules/.pnpm/vfile@5.3.2/node_modules/vfile/lib/index.js","webpack://react-antd-admin/./node_modules/.pnpm/vfile@5.3.2/node_modules/vfile/lib/minurl.browser.js"],"sourcesContent":["// A derivative work based on:\n// <https://github.com/browserify/path-browserify>.\n// Which is licensed:\n//\n// MIT License\n//\n// Copyright (c) 2013 James Halliday\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of\n// this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to\n// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n// the Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A derivative work based on:\n//\n// Parts of that are extracted from Node‚Äôs internal `path` module:\n// <https://github.com/nodejs/node/blob/master/lib/path.js>.\n// Which is licensed:\n//\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nexport const path = {basename, dirname, extname, join, sep: '/'}\n\n/* eslint-disable max-depth, complexity */\n\n/**\n * @param {string} path\n * @param {string} [ext]\n * @returns {string}\n */\nfunction basename(path, ext) {\n  if (ext !== undefined && typeof ext !== 'string') {\n    throw new TypeError('\"ext\" argument must be a string')\n  }\n\n  assertPath(path)\n  let start = 0\n  let end = -1\n  let index = path.length\n  /** @type {boolean|undefined} */\n  let seenNonSlash\n\n  if (ext === undefined || ext.length === 0 || ext.length > path.length) {\n    while (index--) {\n      if (path.charCodeAt(index) === 47 /* `/` */) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now.\n        if (seenNonSlash) {\n          start = index + 1\n          break\n        }\n      } else if (end < 0) {\n        // We saw the first non-path separator, mark this as the end of our\n        // path component.\n        seenNonSlash = true\n        end = index + 1\n      }\n    }\n\n    return end < 0 ? '' : path.slice(start, end)\n  }\n\n  if (ext === path) {\n    return ''\n  }\n\n  let firstNonSlashEnd = -1\n  let extIndex = ext.length - 1\n\n  while (index--) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (seenNonSlash) {\n        start = index + 1\n        break\n      }\n    } else {\n      if (firstNonSlashEnd < 0) {\n        // We saw the first non-path separator, remember this index in case\n        // we need it if the extension ends up not matching.\n        seenNonSlash = true\n        firstNonSlashEnd = index + 1\n      }\n\n      if (extIndex > -1) {\n        // Try to match the explicit extension.\n        if (path.charCodeAt(index) === ext.charCodeAt(extIndex--)) {\n          if (extIndex < 0) {\n            // We matched the extension, so mark this as the end of our path\n            // component\n            end = index\n          }\n        } else {\n          // Extension does not match, so our result is the entire path\n          // component\n          extIndex = -1\n          end = firstNonSlashEnd\n        }\n      }\n    }\n  }\n\n  if (start === end) {\n    end = firstNonSlashEnd\n  } else if (end < 0) {\n    end = path.length\n  }\n\n  return path.slice(start, end)\n}\n\n/**\n * @param {string} path\n * @returns {string}\n */\nfunction dirname(path) {\n  assertPath(path)\n\n  if (path.length === 0) {\n    return '.'\n  }\n\n  let end = -1\n  let index = path.length\n  /** @type {boolean|undefined} */\n  let unmatchedSlash\n\n  // Prefix `--` is important to not run on `0`.\n  while (--index) {\n    if (path.charCodeAt(index) === 47 /* `/` */) {\n      if (unmatchedSlash) {\n        end = index\n        break\n      }\n    } else if (!unmatchedSlash) {\n      // We saw the first non-path separator\n      unmatchedSlash = true\n    }\n  }\n\n  return end < 0\n    ? path.charCodeAt(0) === 47 /* `/` */\n      ? '/'\n      : '.'\n    : end === 1 && path.charCodeAt(0) === 47 /* `/` */\n    ? '//'\n    : path.slice(0, end)\n}\n\n/**\n * @param {string} path\n * @returns {string}\n */\nfunction extname(path) {\n  assertPath(path)\n\n  let index = path.length\n\n  let end = -1\n  let startPart = 0\n  let startDot = -1\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find.\n  let preDotState = 0\n  /** @type {boolean|undefined} */\n  let unmatchedSlash\n\n  while (index--) {\n    const code = path.charCodeAt(index)\n\n    if (code === 47 /* `/` */) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now.\n      if (unmatchedSlash) {\n        startPart = index + 1\n        break\n      }\n\n      continue\n    }\n\n    if (end < 0) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension.\n      unmatchedSlash = true\n      end = index + 1\n    }\n\n    if (code === 46 /* `.` */) {\n      // If this is our first dot, mark it as the start of our extension.\n      if (startDot < 0) {\n        startDot = index\n      } else if (preDotState !== 1) {\n        preDotState = 1\n      }\n    } else if (startDot > -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension.\n      preDotState = -1\n    }\n  }\n\n  if (\n    startDot < 0 ||\n    end < 0 ||\n    // We saw a non-dot character immediately before the dot.\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly `..`.\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    return ''\n  }\n\n  return path.slice(startDot, end)\n}\n\n/**\n * @param {Array<string>} segments\n * @returns {string}\n */\nfunction join(...segments) {\n  let index = -1\n  /** @type {string|undefined} */\n  let joined\n\n  while (++index < segments.length) {\n    assertPath(segments[index])\n\n    if (segments[index]) {\n      joined =\n        joined === undefined ? segments[index] : joined + '/' + segments[index]\n    }\n  }\n\n  return joined === undefined ? '.' : normalize(joined)\n}\n\n/**\n * Note: `normalize` is not exposed as `path.normalize`, so some code is\n * manually removed from it.\n *\n * @param {string} path\n * @returns {string}\n */\nfunction normalize(path) {\n  assertPath(path)\n\n  const absolute = path.charCodeAt(0) === 47 /* `/` */\n\n  // Normalize the path according to POSIX rules.\n  let value = normalizeString(path, !absolute)\n\n  if (value.length === 0 && !absolute) {\n    value = '.'\n  }\n\n  if (value.length > 0 && path.charCodeAt(path.length - 1) === 47 /* / */) {\n    value += '/'\n  }\n\n  return absolute ? '/' + value : value\n}\n\n/**\n * Resolve `.` and `..` elements in a path with directory names.\n *\n * @param {string} path\n * @param {boolean} allowAboveRoot\n * @returns {string}\n */\nfunction normalizeString(path, allowAboveRoot) {\n  let result = ''\n  let lastSegmentLength = 0\n  let lastSlash = -1\n  let dots = 0\n  let index = -1\n  /** @type {number|undefined} */\n  let code\n  /** @type {number} */\n  let lastSlashIndex\n\n  while (++index <= path.length) {\n    if (index < path.length) {\n      code = path.charCodeAt(index)\n    } else if (code === 47 /* `/` */) {\n      break\n    } else {\n      code = 47 /* `/` */\n    }\n\n    if (code === 47 /* `/` */) {\n      if (lastSlash === index - 1 || dots === 1) {\n        // Empty.\n      } else if (lastSlash !== index - 1 && dots === 2) {\n        if (\n          result.length < 2 ||\n          lastSegmentLength !== 2 ||\n          result.charCodeAt(result.length - 1) !== 46 /* `.` */ ||\n          result.charCodeAt(result.length - 2) !== 46 /* `.` */\n        ) {\n          if (result.length > 2) {\n            lastSlashIndex = result.lastIndexOf('/')\n\n            if (lastSlashIndex !== result.length - 1) {\n              if (lastSlashIndex < 0) {\n                result = ''\n                lastSegmentLength = 0\n              } else {\n                result = result.slice(0, lastSlashIndex)\n                lastSegmentLength = result.length - 1 - result.lastIndexOf('/')\n              }\n\n              lastSlash = index\n              dots = 0\n              continue\n            }\n          } else if (result.length > 0) {\n            result = ''\n            lastSegmentLength = 0\n            lastSlash = index\n            dots = 0\n            continue\n          }\n        }\n\n        if (allowAboveRoot) {\n          result = result.length > 0 ? result + '/..' : '..'\n          lastSegmentLength = 2\n        }\n      } else {\n        if (result.length > 0) {\n          result += '/' + path.slice(lastSlash + 1, index)\n        } else {\n          result = path.slice(lastSlash + 1, index)\n        }\n\n        lastSegmentLength = index - lastSlash - 1\n      }\n\n      lastSlash = index\n      dots = 0\n    } else if (code === 46 /* `.` */ && dots > -1) {\n      dots++\n    } else {\n      dots = -1\n    }\n  }\n\n  return result\n}\n\n/**\n * @param {string} path\n */\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError(\n      'Path must be a string. Received ' + JSON.stringify(path)\n    )\n  }\n}\n\n/* eslint-enable max-depth, complexity */\n","// Somewhat based on:\n// <https://github.com/defunctzombie/node-process/blob/master/browser.js>.\n// But I don‚Äôt think one tiny line of code can be copyrighted. üòÖ\nexport const proc = {cwd}\n\nfunction cwd() {\n  return '/'\n}\n","/**\n * @typedef URL\n * @property {string} hash\n * @property {string} host\n * @property {string} hostname\n * @property {string} href\n * @property {string} origin\n * @property {string} password\n * @property {string} pathname\n * @property {string} port\n * @property {string} protocol\n * @property {string} search\n * @property {any} searchParams\n * @property {string} username\n * @property {() => string} toString\n * @property {() => string} toJSON\n */\n\n/**\n * @param {unknown} fileURLOrPath\n * @returns {fileURLOrPath is URL}\n */\n// From: <https://github.com/nodejs/node/blob/fcf8ba4/lib/internal/url.js#L1501>\nexport function isUrl(fileURLOrPath) {\n  return (\n    fileURLOrPath !== null &&\n    typeof fileURLOrPath === 'object' &&\n    // @ts-expect-error: indexable.\n    fileURLOrPath.href &&\n    // @ts-expect-error: indexable.\n    fileURLOrPath.origin\n  )\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Position} Position\n * @typedef {import('unist').Point} Point\n * @typedef {Record<string, unknown> & {type: string, position?: Position|undefined}} NodeLike\n * @typedef {import('./minurl.shared.js').URL} URL\n * @typedef {import('..').VFileData} VFileData\n * @typedef {import('..').VFileValue} VFileValue\n *\n * @typedef {'ascii'|'utf8'|'utf-8'|'utf16le'|'ucs2'|'ucs-2'|'base64'|'base64url'|'latin1'|'binary'|'hex'} BufferEncoding\n *   Encodings supported by the buffer class.\n *   This is a copy of the typing from Node, copied to prevent Node globals from\n *   being needed.\n *   Copied from: <https://github.com/DefinitelyTyped/DefinitelyTyped/blob/90a4ec8/types/node/buffer.d.ts#L170>\n *\n * @typedef {VFileValue|VFileOptions|VFile|URL} VFileCompatible\n *   Things that can be passed to the constructor.\n *\n * @typedef VFileCoreOptions\n * @property {VFileValue} [value]\n * @property {string} [cwd]\n * @property {Array<string>} [history]\n * @property {string|URL} [path]\n * @property {string} [basename]\n * @property {string} [stem]\n * @property {string} [extname]\n * @property {string} [dirname]\n * @property {VFileData} [data]\n *\n * @typedef Map\n *   Raw source map, see:\n *   <https://github.com/mozilla/source-map/blob/58819f0/source-map.d.ts#L15-L23>.\n * @property {number} version\n * @property {Array<string>} sources\n * @property {Array<string>} names\n * @property {string|undefined} [sourceRoot]\n * @property {Array<string>|undefined} [sourcesContent]\n * @property {string} mappings\n * @property {string} file\n *\n * @typedef {{[key: string]: unknown} & VFileCoreOptions} VFileOptions\n *   Configuration: a bunch of keys that will be shallow copied over to the new\n *   file.\n *\n * @typedef {Record<string, unknown>} VFileReporterSettings\n * @typedef {<T = VFileReporterSettings>(files: Array<VFile>, options: T) => string} VFileReporter\n */\n\nimport buffer from 'is-buffer'\nimport {VFileMessage} from 'vfile-message'\nimport {path} from './minpath.js'\nimport {proc} from './minproc.js'\nimport {urlToPath, isUrl} from './minurl.js'\n\n// Order of setting (least specific to most), we need this because otherwise\n// `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a\n// stem can be set.\nconst order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname']\n\nexport class VFile {\n  /**\n   * Create a new virtual file.\n   *\n   * If `options` is `string` or `Buffer`, treats it as `{value: options}`.\n   * If `options` is a `VFile`, shallow copies its data over to the new file.\n   * All other given fields are set on the newly created `VFile`.\n   *\n   * Path related properties are set in the following order (least specific to\n   * most specific): `history`, `path`, `basename`, `stem`, `extname`,\n   * `dirname`.\n   *\n   * It‚Äôs not possible to set either `dirname` or `extname` without setting\n   * either `history`, `path`, `basename`, or `stem` as well.\n   *\n   * @param {VFileCompatible} [value]\n   */\n  constructor(value) {\n    /** @type {VFileOptions} */\n    let options\n\n    if (!value) {\n      options = {}\n    } else if (typeof value === 'string' || buffer(value)) {\n      // @ts-expect-error Looks like a buffer.\n      options = {value}\n    } else if (isUrl(value)) {\n      options = {path: value}\n    } else {\n      // @ts-expect-error Looks like file or options.\n      options = value\n    }\n\n    /**\n     * Place to store custom information.\n     * It‚Äôs OK to store custom data directly on the file, moving it to `data`\n     * gives a little more privacy.\n     * @type {VFileData}\n     */\n    this.data = {}\n\n    /**\n     * List of messages associated with the file.\n     * @type {Array<VFileMessage>}\n     */\n    this.messages = []\n\n    /**\n     * List of file paths the file moved between.\n     * @type {Array<string>}\n     */\n    this.history = []\n\n    /**\n     * Base of `path`.\n     * Defaults to `process.cwd()` (`/` in browsers).\n     * @type {string}\n     */\n    this.cwd = proc.cwd()\n\n    /* eslint-disable no-unused-expressions */\n    /**\n     * Raw value.\n     * @type {VFileValue}\n     */\n    this.value\n\n    // The below are non-standard, they are ‚Äúwell-known‚Äù.\n    // As in, used in several tools.\n\n    /**\n     * Whether a file was saved to disk.\n     * This is used by vfile reporters.\n     * @type {boolean}\n     */\n    this.stored\n\n    /**\n     * Sometimes files have a non-string representation.\n     * This can be stored in the `result` field.\n     * One example is when turning markdown into React nodes.\n     * This is used by unified to store non-string results.\n     * @type {unknown}\n     */\n    this.result\n\n    /**\n     * Sometimes files have a source map associated with them.\n     * This can be stored in the `map` field.\n     * This should be a `RawSourceMap` type from the `source-map` module.\n     * @type {Map|undefined}\n     */\n    this.map\n    /* eslint-enable no-unused-expressions */\n\n    // Set path related properties in the correct order.\n    let index = -1\n\n    while (++index < order.length) {\n      const prop = order[index]\n\n      // Note: we specifically use `in` instead of `hasOwnProperty` to accept\n      // `vfile`s too.\n      if (prop in options && options[prop] !== undefined) {\n        // @ts-expect-error: TS is confused by the different types for `history`.\n        this[prop] = prop === 'history' ? [...options[prop]] : options[prop]\n      }\n    }\n\n    /** @type {string} */\n    let prop\n\n    // Set non-path related properties.\n    for (prop in options) {\n      // @ts-expect-error: fine to set other things.\n      if (!order.includes(prop)) this[prop] = options[prop]\n    }\n  }\n\n  /**\n   * Access full path (`~/index.min.js`).\n   *\n   * @returns {string}\n   */\n  get path() {\n    return this.history[this.history.length - 1]\n  }\n\n  /**\n   * Set full path (`~/index.min.js`).\n   * Cannot be nullified.\n   *\n   * @param {string|URL} path\n   */\n  set path(path) {\n    if (isUrl(path)) {\n      path = urlToPath(path)\n    }\n\n    assertNonEmpty(path, 'path')\n\n    if (this.path !== path) {\n      this.history.push(path)\n    }\n  }\n\n  /**\n   * Access parent path (`~`).\n   */\n  get dirname() {\n    return typeof this.path === 'string' ? path.dirname(this.path) : undefined\n  }\n\n  /**\n   * Set parent path (`~`).\n   * Cannot be set if there's no `path` yet.\n   */\n  set dirname(dirname) {\n    assertPath(this.basename, 'dirname')\n    this.path = path.join(dirname || '', this.basename)\n  }\n\n  /**\n   * Access basename (including extname) (`index.min.js`).\n   */\n  get basename() {\n    return typeof this.path === 'string' ? path.basename(this.path) : undefined\n  }\n\n  /**\n   * Set basename (`index.min.js`).\n   * Cannot contain path separators.\n   * Cannot be nullified either (use `file.path = file.dirname` instead).\n   */\n  set basename(basename) {\n    assertNonEmpty(basename, 'basename')\n    assertPart(basename, 'basename')\n    this.path = path.join(this.dirname || '', basename)\n  }\n\n  /**\n   * Access extname (including dot) (`.js`).\n   */\n  get extname() {\n    return typeof this.path === 'string' ? path.extname(this.path) : undefined\n  }\n\n  /**\n   * Set extname (including dot) (`.js`).\n   * Cannot be set if there's no `path` yet and cannot contain path separators.\n   */\n  set extname(extname) {\n    assertPart(extname, 'extname')\n    assertPath(this.dirname, 'extname')\n\n    if (extname) {\n      if (extname.charCodeAt(0) !== 46 /* `.` */) {\n        throw new Error('`extname` must start with `.`')\n      }\n\n      if (extname.includes('.', 1)) {\n        throw new Error('`extname` cannot contain multiple dots')\n      }\n    }\n\n    this.path = path.join(this.dirname, this.stem + (extname || ''))\n  }\n\n  /**\n   * Access stem (w/o extname) (`index.min`).\n   */\n  get stem() {\n    return typeof this.path === 'string'\n      ? path.basename(this.path, this.extname)\n      : undefined\n  }\n\n  /**\n   * Set stem (w/o extname) (`index.min`).\n   * Cannot be nullified, and cannot contain path separators.\n   */\n  set stem(stem) {\n    assertNonEmpty(stem, 'stem')\n    assertPart(stem, 'stem')\n    this.path = path.join(this.dirname || '', stem + (this.extname || ''))\n  }\n\n  /**\n   * Serialize the file.\n   *\n   * @param {BufferEncoding} [encoding='utf8'] If `file.value` is a buffer, `encoding` is used to serialize buffers.\n   * @returns {string}\n   */\n  toString(encoding) {\n    return (this.value || '').toString(encoding)\n  }\n\n  /**\n   * Create a message and associates it w/ the file.\n   *\n   * @param {string|Error} reason Reason for message (`string` or `Error`). Uses the stack and message of the error if given.\n   * @param {Node|NodeLike|Position|Point} [place] Place at which the message occurred in a file (`Node`, `Position`, or `Point`, optional).\n   * @param {string} [origin] Place in code the message originates from (`string`, optional).\n   * @returns {VFileMessage}\n   */\n  message(reason, place, origin) {\n    const message = new VFileMessage(reason, place, origin)\n\n    if (this.path) {\n      message.name = this.path + ':' + message.name\n      message.file = this.path\n    }\n\n    message.fatal = false\n\n    this.messages.push(message)\n\n    return message\n  }\n\n  /**\n   * Info: create a message, associate it with the file, and mark the fatality\n   * as `null`.\n   * Calls `message()` internally.\n   *\n   * @param {string|Error} reason Reason for message (`string` or `Error`). Uses the stack and message of the error if given.\n   * @param {Node|NodeLike|Position|Point} [place] Place at which the message occurred in a file (`Node`, `Position`, or `Point`, optional).\n   * @param {string} [origin] Place in code the message originates from (`string`, optional).\n   * @returns {VFileMessage}\n   */\n  info(reason, place, origin) {\n    const message = this.message(reason, place, origin)\n\n    message.fatal = null\n\n    return message\n  }\n\n  /**\n   * Fail: create a message, associate it with the file, mark the fatality as\n   * `true`.\n   * Note: fatal errors mean a file is no longer processable.\n   * Calls `message()` internally.\n   *\n   * @param {string|Error} reason Reason for message (`string` or `Error`). Uses the stack and message of the error if given.\n   * @param {Node|NodeLike|Position|Point} [place] Place at which the message occurred in a file (`Node`, `Position`, or `Point`, optional).\n   * @param {string} [origin] Place in code the message originates from (`string`, optional).\n   * @returns {never}\n   */\n  fail(reason, place, origin) {\n    const message = this.message(reason, place, origin)\n\n    message.fatal = true\n\n    throw message\n  }\n}\n\n/**\n * Assert that `part` is not a path (as in, does not contain `path.sep`).\n *\n * @param {string|undefined} part\n * @param {string} name\n * @returns {void}\n */\nfunction assertPart(part, name) {\n  if (part && part.includes(path.sep)) {\n    throw new Error(\n      '`' + name + '` cannot be a path: did not expect `' + path.sep + '`'\n    )\n  }\n}\n\n/**\n * Assert that `part` is not empty.\n *\n * @param {string|undefined} part\n * @param {string} name\n * @returns {asserts part is string}\n */\nfunction assertNonEmpty(part, name) {\n  if (!part) {\n    throw new Error('`' + name + '` cannot be empty')\n  }\n}\n\n/**\n * Assert `path` exists.\n *\n * @param {string|undefined} path\n * @param {string} name\n * @returns {asserts path is string}\n */\nfunction assertPath(path, name) {\n  if (!path) {\n    throw new Error('Setting `' + name + '` requires `path` to be set too')\n  }\n}\n","/// <reference lib=\"dom\" />\n\nimport {isUrl} from './minurl.shared.js'\n\n// See: <https://github.com/nodejs/node/blob/fcf8ba4/lib/internal/url.js>\n\n/**\n * @param {string|URL} path\n */\nexport function urlToPath(path) {\n  if (typeof path === 'string') {\n    path = new URL(path)\n  } else if (!isUrl(path)) {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError(\n      'The \"path\" argument must be of type string or an instance of URL. Received `' +\n        path +\n        '`'\n    )\n    error.code = 'ERR_INVALID_ARG_TYPE'\n    throw error\n  }\n\n  if (path.protocol !== 'file:') {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError('The URL must be of scheme file')\n    error.code = 'ERR_INVALID_URL_SCHEME'\n    throw error\n  }\n\n  return getPathFromURLPosix(path)\n}\n\n/**\n * @param {URL} url\n */\nfunction getPathFromURLPosix(url) {\n  if (url.hostname !== '') {\n    /** @type {NodeJS.ErrnoException} */\n    const error = new TypeError(\n      'File URL host must be \"localhost\" or empty on darwin'\n    )\n    error.code = 'ERR_INVALID_FILE_URL_HOST'\n    throw error\n  }\n\n  const pathname = url.pathname\n  let index = -1\n\n  while (++index < pathname.length) {\n    if (\n      pathname.charCodeAt(index) === 37 /* `%` */ &&\n      pathname.charCodeAt(index + 1) === 50 /* `2` */\n    ) {\n      const third = pathname.charCodeAt(index + 2)\n      if (third === 70 /* `F` */ || third === 102 /* `f` */) {\n        /** @type {NodeJS.ErrnoException} */\n        const error = new TypeError(\n          'File URL path must not include encoded / characters'\n        )\n        error.code = 'ERR_INVALID_FILE_URL_PATH'\n        throw error\n      }\n    }\n  }\n\n  return decodeURIComponent(pathname)\n}\n\nexport {isUrl} from './minurl.shared.js'\n"],"names":["path","ext","undefined","TypeError","assertPath","seenNonSlash","start","end","index","length","charCodeAt","slice","firstNonSlashEnd","extIndex","unmatchedSlash","startPart","startDot","preDotState","code","segments","joined","absolute","value","allowAboveRoot","lastSlashIndex","result","lastSegmentLength","lastSlash","dots","lastIndexOf","normalizeString","normalize","JSON","stringify","proc","isUrl","fileURLOrPath","href","origin","order","VFile","constructor","options","this","data","messages","history","cwd","stored","map","prop","includes","URL","error","protocol","url","hostname","pathname","third","decodeURIComponent","getPathFromURLPosix","urlToPath","assertNonEmpty","push","dirname","basename","assertPart","extname","Error","stem","toString","encoding","message","reason","place","name","file","fatal","info","fail","part"],"sourceRoot":""}