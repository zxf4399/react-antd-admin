{"version":3,"file":".pnpm/mdast-util-from-markdown@1.2.0/node_modules/mdast-util-from-markdown/lib.ee56e2a92624a10066b0.js","mappings":"sPA4FA,MAAMA,EAAM,GAAGC,eAOFC,EAcX,SAAUC,EAAOC,EAAUC,GAMzB,MALwB,iBAAbD,IACTC,EAAUD,EACVA,OAAWE,GAejB,SAAkBD,EAAU,IAG1B,MAAME,EAASC,EACb,CACEC,WAAY,GACZC,eAAgB,CACd,WACA,WACA,UACA,YACA,UAEFC,MAAO,CACLC,SAAUC,EAAOC,GACjBC,iBAAkBC,EAClBC,cAAeD,EACfE,WAAYL,EAAOM,GACnBC,WAAYP,GA41BlB,WACE,MAAO,CACLQ,KAAM,aACNC,SAAU,OA91BRC,gBAAiBP,EACjBQ,mBAAoBR,EACpBS,WAAYZ,EAAOa,GACnBC,oBAAqBC,EACrBC,oBAAqBD,EACrBE,aAAcjB,EAAOa,EAAUE,GAC/BG,SAAUlB,GAu2BhB,WACE,MAAO,CACLQ,KAAM,aACNlB,MAAO,MA12BsByB,GAC3BI,aAAchB,EACdiB,KAAMjB,EACNkB,cAAelB,EACfmB,WAAYtB,GA22BlB,WACE,MAAO,CACLQ,KAAM,aACNe,WAAY,GACZC,MAAO,KACPC,MAAO,KACPC,IAAK,OAh3BHC,4BAA6BZ,EAC7Ba,sBAAuBb,EACvBc,sBAAuBd,EACvBe,SAAU9B,GAk3BhB,WACE,MAAO,CACLQ,KAAM,WACNC,SAAU,OAp3BRsB,gBAAiB/B,EAAOgC,GACxBC,kBAAmBjC,EAAOgC,GAC1BE,SAAUlC,EAAOmC,EAAMpB,GACvBqB,aAAcjC,EACdkC,SAAUrC,EAAOmC,EAAMpB,GACvBuB,aAAcnC,EACdoC,MAAOvC,GA44Bb,WACE,MAAO,CACLQ,KAAM,QACNiB,MAAO,KACPC,IAAK,GACLc,IAAK,SAh5BHhB,MAAOT,EACPd,KAAMD,EAAOC,GACbwC,SAAUzC,GA+6BhB,SAAkB0C,GAChB,MAAO,CACLlC,KAAM,WAENmC,OAAQD,EAAME,QACdC,QAAS,KACTpC,SAAU,OAp7BRqC,cAidN,SAA8BJ,GACxBK,EAAQ,iCAGRC,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GACxBC,MAAQC,OAAOC,SAASL,KAAKM,eAAeZ,GAAQ,IAC7Da,EAAQ,iCAtdNC,YAAaxD,EAAOyD,GA2c1B,WACEF,EAAQ,+BAA+B,MA3cnCG,cAAe1D,EAAOyD,GACtBE,UAAW3D,GAs7BjB,WACE,MAAO,CACLQ,KAAM,YACNC,SAAU,OAx7BRmD,UAwvBN,WACEL,EAAQ,gBAAiB,cAxvBrBM,gBAAiB9C,EACjB+C,0BAA2B/C,EAC3BgD,oBAAqBhD,EACrBiD,cAAehE,EAAOM,GACtB2D,OAAQjE,GAw7Bd,WACE,MAAO,CACLQ,KAAM,SACNC,SAAU,OA17BRyD,cAAelE,GAu8BrB,WACE,MAAO,CACLQ,KAAM,qBAv8BN2D,KAAM,CACJ9D,WAAY+D,IACZC,mBA0hBN,SAAkC3B,GAChC,MAAM4B,EAEJtB,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GAEjC,IAAKoB,EAAKC,MAAO,CACf,MAAMA,EAAQvB,KAAKM,eAAeZ,GAAOQ,OACzCoB,EAAKC,MAAQA,IAhiBXxE,SAAUqE,IACVhE,cAsyBN,SAA6BsC,GAC3B8B,EAAWC,KAAKzB,KAAMN,GAGpBM,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GAC5BxB,IAAM,UAAYsB,KAAKM,eAAeZ,IA1yBvCxC,iBA4xBN,SAAgCwC,GAC9B8B,EAAWC,KAAKzB,KAAMN,GAGpBM,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GAC5BxB,IAAMsB,KAAKM,eAAeZ,IAhyB3BnC,WAAY6D,IACZM,qBAAsBF,EACtBG,oCAAqCC,EACrCC,gCAAiCD,EACjCE,wBA6vBN,SAAuCpC,GACrC,MAAMtB,EAAO4B,KAAKM,eAAeZ,GAC3BlC,EAAOuC,EAAQ,0BAGrB,IAAIzD,EAEAkB,GACFlB,GAAQ,OACN8B,EACS,oCAATZ,EAA6C,GAAK,IAEpD+C,EAAQ,2BAKRjE,GAAQ,OAA8B8B,GAGxC,MAAM2D,EAAO/B,KAAKC,MAAM+B,MACxBD,EAAKzF,OAASA,EACdyF,EAAKE,SAASC,IAAMC,EAAMzC,EAAMwC,MAlxB5BtE,WAAYwD,GA+dlB,WACE,MAAMhD,EAAO4B,KAAKoC,SAGhBpC,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GAC5B5D,MAAQ8B,EAAKiE,QAAQ,2BAA4B,IACtD9B,EAAQ,qBApeJ+B,gBAsdN,WAEMvC,EAAQ,oBACZC,KAAKjC,SACLwC,EAAQ,kBAAkB,KAzdtBzC,oBAmcN,WACE,MAAMM,EAAO4B,KAAKoC,SAGhBpC,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GAC5BqC,KAAOnE,GAvcRJ,oBA2cN,WACE,MAAMI,EAAO4B,KAAKoC,SAGhBpC,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GAC5BsC,KAAOpE,GA/cRC,cAAemD,EACfvD,aAAcmD,GAoepB,WACE,MAAMhD,EAAO4B,KAAKoC,SAGhBpC,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GAC5B5D,MAAQ8B,EAAKiE,QAAQ,eAAgB,OAxetCnE,SAAUkD,GAmnBhB,WACE,MAAMhD,EAAO4B,KAAKoC,SAGhBpC,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GAC5B5D,MAAQ8B,KAvnBTD,aAAcqD,EACdpD,KAAMoD,EACNlD,WAAY8C,IACZzC,4BA8fN,WACE,MAAMP,EAAO4B,KAAKoC,SAGhBpC,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GAC5BxB,IAAMN,GAlgBPQ,sBAueN,SAAqCc,GAEnC,MAAMlB,EAAQwB,KAAKoC,SACbd,EAEJtB,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GACjCoB,EAAK9C,MAAQA,EACb8C,EAAK/C,YAAa,OAChByB,KAAKM,eAAeZ,IACpB+C,eA/eE5D,sBAmfN,WACE,MAAMT,EAAO4B,KAAKoC,SAGhBpC,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GAC5BzB,MAAQL,GAvfTU,SAAUsC,IACVrC,gBAAiBqC,EAAOsB,GACxBzD,kBAAmBmC,EAAOsB,GAC1BxD,SAAUkC,GAulBhB,WACE,MAAMhD,EAAO4B,KAAKoC,SAGhBpC,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GAC5B5D,MAAQ8B,KA3lBTgB,aAAcoC,EACdnC,SAAU+B,GA8lBhB,WACE,MAAMhD,EAAO4B,KAAKoC,SAGhBpC,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GAC5B5D,MAAQ8B,KAlmBTkB,aAAckC,EACdjC,MAAO6B,GAqoBb,WACE,MAAMuB,EAEJ3C,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GAE7BH,EAAQ,gBACV4C,EAAQnF,MAAQ,YAEhBmF,EAAQC,cAAgB7C,EAAQ,kBAAoB,kBAE7C4C,EAAQjE,WACRiE,EAAQlE,eAGRkE,EAAQpE,kBAERoE,EAAQnE,OAGjB+B,EAAQ,oBAvpBJ/B,MAqqBN,WACE,MAAMqE,EAEJ7C,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GAC3B5D,EAAQ0D,KAAKoC,SACbd,EAEJtB,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GAEjCK,EAAQ,eAAe,GAEL,SAAde,EAAK9D,KAEP8D,EAAK7D,SAAWoF,EAASpF,SAEzB6D,EAAK9B,IAAMlD,GAnrBTwG,UA0pBN,SAAyBpD,GACvB,MAAMqD,EAEJ/C,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GAC3B8C,EAAShD,KAAKM,eAAeZ,GACnCqD,EAASvE,OAAQ,OAAawE,GAC9BD,EAASxE,YAAa,OAAoByE,GAAQP,eA/pB9CQ,WAsjBN,SAA0BvD,GACxB,MAAMiD,EAAU3C,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GAG/C,GAAIH,EAAQ,eAIV,OAHa4C,EAAQlF,SAASkF,EAAQlF,SAASyC,OAAS,GACnD+B,SAASC,IAAMC,EAAMzC,EAAMwC,UAChC3B,EAAQ,gBAKPR,EAAQ,iCACTrD,EAAOG,eAAeqG,SAASP,EAAQnF,QAEvCL,EAAYsE,KAAKzB,KAAMN,GACvB8B,EAAWC,KAAKzB,KAAMN,KArkBpBzC,KAAMmE,GA0mBZ,WACE,MAAMuB,EAEJ3C,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GAE7BH,EAAQ,gBACV4C,EAAQnF,MAAQ,YAEhBmF,EAAQC,cAAgB7C,EAAQ,kBAAoB,kBAE7C4C,EAAQjE,WACRiE,EAAQlE,eAGRkE,EAAQpE,kBAERoE,EAAQnE,OAGjB+B,EAAQ,oBA5nBJd,SAAU2B,IACVZ,YAAaY,IACbV,cAAeU,IACfT,UAAWS,IACXP,gBA6sBN,SAA+BnB,GAC7B,MAAMlB,EAAQwB,KAAKoC,SACbd,EAEJtB,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GACjCoB,EAAK9C,MAAQA,EACb8C,EAAK/C,YAAa,OAChByB,KAAKM,eAAeZ,IACpB+C,cACFlC,EAAQ,gBAAiB,SArtBrBO,0BAgrBN,WACE,MAAM1C,EAAO4B,KAAKoC,SAGhBpC,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GAC5BxB,IAAMN,GAprBP2C,oBAwrBN,WACE,MAAM3C,EAAO4B,KAAKoC,SAGhBpC,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GAC5BzB,MAAQL,GA5rBT+E,SAgsBN,WACE5C,EAAQ,gBAhsBJS,cAAeI,GAygBrB,WACEb,EAAQ,mCAzgBJ6C,0BAggBN,SAAyC1D,GAGrCM,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GAC5BqB,MAAqD,KAA7CvB,KAAKM,eAAeZ,GAAO2D,WAAW,GAAY,EAAI,GAngB/DC,kBA0fN,WACE/C,EAAQ,gCAAgC,IA1fpCU,OAAQG,IACRF,cAAeE,MAGnB5E,EAAQ+G,iBAAmB,IAIvBnF,EAAO,GACb,OAMA,SAAiBoF,GAEf,IAAIC,EAAO,CACTjG,KAAM,OACNC,SAAU,IAIZ,MAGMiG,EAAa,GAGbC,EAAY,GAGZhB,EAAU,CACd1C,MAVY,CAACwD,GAWbC,WAAAA,EACAhH,OAAAA,EACAI,MAAAA,EACAqE,KAAAA,EACApD,OAAAA,EACAqE,OAAAA,EACA7B,QAAAA,EACAR,QAAAA,GAEF,IAAI6D,GAAS,EAEb,OAASA,EAAQJ,EAAOtD,QAIM,gBAA1BsD,EAAOI,GAAO,GAAGpG,MACS,kBAA1BgG,EAAOI,GAAO,GAAGpG,OAEQ,UAArBgG,EAAOI,GAAO,GAChBD,EAAUE,KAAKD,GAGfA,EAAQE,EAAYN,EADPG,EAAU3B,MACW4B,IAOxC,IAFAA,GAAS,IAEAA,EAAQJ,EAAOtD,QAAQ,CAC9B,MAAM6D,EAAUrH,EAAO8G,EAAOI,GAAO,IAEjCzH,EAAIsF,KAAKsC,EAASP,EAAOI,GAAO,GAAGpG,OACrCuG,EAAQP,EAAOI,GAAO,GAAGpG,MAAMiE,KAC7BuC,OAAOC,OACL,CACE3D,eAAgBkD,EAAOI,GAAO,GAAGtD,gBAEnCqC,GAEFa,EAAOI,GAAO,IAKpB,GAAIF,EAAWxD,OAAS,EAAG,CACzB,MAAM6B,EAAO2B,EAAWA,EAAWxD,OAAS,IAC5B6B,EAAK,IAAMmC,GACnBzC,KAAKkB,OAASlG,EAAWsF,EAAK,IAyBxC,IAtBA0B,EAAKxB,SAAW,CACd9B,MAAOgC,EACLqB,EAAOtD,OAAS,EACZsD,EAAO,GAAG,GAAGrD,MACb,CACEgE,KAAM,EACNC,OAAQ,EACRC,OAAQ,IAGhBnC,IAAKC,EACHqB,EAAOtD,OAAS,EACZsD,EAAOA,EAAOtD,OAAS,GAAG,GAAGgC,IAC7B,CACEiC,KAAM,EACNC,OAAQ,EACRC,OAAQ,KAIlBT,GAAS,IAEAA,EAAQlH,EAAOE,WAAWsD,QACjCuD,EAAO/G,EAAOE,WAAWgH,GAAOH,IAASA,EAG3C,OAAOA,GAST,SAASK,EAAYN,EAAQrD,EAAOD,GAClC,IAKIT,EAGA6E,EAGAC,EAGAC,EAdAZ,EAAQzD,EAAQ,EAChBsE,GAAoB,EACpBC,GAAa,EAcjB,OAASd,GAAS1D,GAAQ,CACxB,MAAMyE,EAAQnB,EAAOI,GAuCrB,GApCoB,kBAAlBe,EAAM,GAAGnH,MACS,gBAAlBmH,EAAM,GAAGnH,MACS,eAAlBmH,EAAM,GAAGnH,MAEQ,UAAbmH,EAAM,GACRF,IAEAA,IAGFD,OAAW/H,GACgB,oBAAlBkI,EAAM,GAAGnH,KACD,UAAbmH,EAAM,MAENlF,GACC+E,GACAC,GACAF,IAEDA,EAAsBX,GAGxBY,OAAW/H,GAGK,eAAlBkI,EAAM,GAAGnH,MACS,kBAAlBmH,EAAM,GAAGnH,MACS,mBAAlBmH,EAAM,GAAGnH,MACS,mBAAlBmH,EAAM,GAAGnH,MACS,6BAAlBmH,EAAM,GAAGnH,OAITgH,OAAW/H,IAITgI,GACa,UAAbE,EAAM,IACY,mBAAlBA,EAAM,GAAGnH,OACY,IAAtBiH,GACc,SAAbE,EAAM,KACa,kBAAlBA,EAAM,GAAGnH,MACU,gBAAlBmH,EAAM,GAAGnH,MACb,CACA,GAAIiC,EAAU,CACZ,IAAImF,EAAYhB,EAGhB,IAFAU,OAAY7H,EAELmI,KAAa,CAClB,MAAMC,EAAYrB,EAAOoB,GAEzB,GACwB,eAAtBC,EAAU,GAAGrH,MACS,oBAAtBqH,EAAU,GAAGrH,KACb,CACA,GAAqB,SAAjBqH,EAAU,GAAe,SAEzBP,IACFd,EAAOc,GAAW,GAAG9G,KAAO,kBAC5BkH,GAAa,GAGfG,EAAU,GAAGrH,KAAO,aACpB8G,EAAYM,OACP,GACiB,eAAtBC,EAAU,GAAGrH,MACS,qBAAtBqH,EAAU,GAAGrH,MACS,+BAAtBqH,EAAU,GAAGrH,MACS,qBAAtBqH,EAAU,GAAGrH,MACS,mBAAtBqH,EAAU,GAAGrH,KAIb,MAKF+G,KACED,GAAaC,EAAsBD,KAGrC7E,EAASG,SAAU,GAGrBH,EAASyC,IAAM8B,OAAOC,OACpB,GACAK,EAAYd,EAAOc,GAAW,GAAGnE,MAAQwE,EAAM,GAAGzC,KAEpDsB,EAAOsB,OAAOR,GAAaV,EAAO,EAAG,CAAC,OAAQnE,EAAUkF,EAAM,KAC9Df,IACA1D,IAGoB,mBAAlByE,EAAM,GAAGnH,OACXiC,EAAW,CACTjC,KAAM,WAENoC,SAAS,EACTO,MAAO6D,OAAOC,OAAO,GAAIU,EAAM,GAAGxE,QAGpCqD,EAAOsB,OAAOlB,EAAO,EAAG,CAAC,QAASnE,EAAUkF,EAAM,KAClDf,IACA1D,IACAqE,OAAsB9H,EACtB+H,GAAW,IAMjB,OADAhB,EAAOrD,GAAO,GAAGP,QAAU8E,EACpBxE,EAOT,SAASK,EAAQwE,EAAKzI,GACpB8B,EAAK2G,GAAOzI,EASd,SAASyD,EAAQgF,GACf,OAAO3G,EAAK2G,GAOd,SAAS5C,EAAM6C,GACb,MAAO,CACLb,KAAMa,EAAEb,KACRC,OAAQY,EAAEZ,OACVC,OAAQW,EAAEX,QASd,SAASrH,EAAOiI,EAAQC,GACtB,OAOA,SAAcxF,GACZ5C,EAAM2E,KAAKzB,KAAMiF,EAAOvF,GAAQA,GAC5BwF,GAAKA,EAAIzD,KAAKzB,KAAMN,IAK5B,SAAS3B,IACPiC,KAAKC,MAAM4D,KAAK,CACdrG,KAAM,WACNC,SAAU,KAad,SAASX,EAAMwE,EAAM5B,EAAOyF,GAU1B,OATenF,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GAEvCzC,SAASoG,KAAKvC,GACrBtB,KAAKC,MAAM4D,KAAKvC,GAChBtB,KAAK0D,WAAWG,KAAK,CAACnE,EAAOyF,IAE7B7D,EAAKW,SAAW,CACd9B,MAAOgC,EAAMzC,EAAMS,QAEdmB,EAOT,SAASF,EAAO8D,GACd,OAOA,SAAexF,GACTwF,GAAKA,EAAIzD,KAAKzB,KAAMN,GACxByB,EAAKM,KAAKzB,KAAMN,IAWpB,SAASyB,EAAKzB,EAAO0F,GACnB,MAAM9D,EAAOtB,KAAKC,MAAM+B,MAClBqD,EAAOrF,KAAK0D,WAAW1B,MAE7B,IAAKqD,EACH,MAAM,IAAIC,MACR,iBACE5F,EAAMlC,KACN,OACA,OAAkB,CAChB2C,MAAOT,EAAMS,MACb+B,IAAKxC,EAAMwC,MAEb,oBAYN,OAVWmD,EAAK,GAAG7H,OAASkC,EAAMlC,OAC5B4H,EACFA,EAAY3D,KAAKzB,KAAMN,EAAO2F,EAAK,KAEnBA,EAAK,IAAMnB,GACnBzC,KAAKzB,KAAMN,EAAO2F,EAAK,KAInC/D,EAAKW,SAASC,IAAMC,EAAMzC,EAAMwC,KACzBZ,EAOT,SAASc,IACP,OAAO,OAASpC,KAAKC,MAAM+B,OAiI7B,SAAS7E,EAAYuC,GACnB,MAAM6F,EAEJvF,KAAKC,MAAMD,KAAKC,MAAMC,OAAS,GAGjC,IAAI6B,EAAOwD,EAAO9H,SAAS8H,EAAO9H,SAASyC,OAAS,GAE/C6B,GAAsB,SAAdA,EAAKvE,OAEhBuE,EA0XK,CACLvE,KAAM,OACNlB,MAAO,IA1XPyF,EAAKE,SAAW,CACd9B,MAAOgC,EAAMzC,EAAMS,QAGrBoF,EAAO9H,SAASoG,KAAK9B,IAGvB/B,KAAKC,MAAM4D,KAAK9B,GAIlB,SAASP,EAAW9B,GAClB,MAAMqC,EAAO/B,KAAKC,MAAM+B,MACxBD,EAAKzF,OAAS0D,KAAKM,eAAeZ,GAClCqC,EAAKE,SAASC,IAAMC,EAAMzC,EAAMwC,KAyBlC,SAASQ,IACPnC,EAAQ,eAAe,GAoJzB,SAASqB,EAA+BlC,GACtCa,EAAQ,yBAA0Bb,EAAMlC,MA2D1C,SAASK,IACP,MAAO,CACLL,KAAM,OACN+E,KAAM,KACNC,KAAM,KACNlG,MAAO,IAgCX,SAASgB,IAEP,MAAO,CACLE,KAAM,UACN+D,WAAO9E,EACPgB,SAAU,IAKd,SAASuB,IACP,MAAO,CACLxB,KAAM,SAKV,SAAS2B,IACP,MAAO,CACL3B,KAAM,OACNlB,MAAO,IAeX,SAASW,IACP,MAAO,CACLO,KAAM,OACNiB,MAAO,KACPC,IAAK,GACLjB,SAAU,IAQd,SAASgD,EAAKf,GACZ,MAAO,CACLlC,KAAM,OACNgI,QAAwB,gBAAf9F,EAAMlC,KACf2C,MAAO,KAEPR,OAAQD,EAAME,QACdnC,SAAU,KA99BLgI,CAASjJ,EAATiJ,EACL,QACE,OAAMjJ,GAASkJ,WAAWC,OAAM,SAAarJ,EAAOC,GAAU,OAmhCtE,SAASI,EAAUiJ,EAAUC,GAC3B,IAAIjC,GAAS,EAEb,OAASA,EAAQiC,EAAW3F,QAAQ,CAClC,MAAM5D,EAAQuJ,EAAWjC,GAErBkC,MAAMC,QAAQzJ,GAChBK,EAAUiJ,EAAUtJ,GAEpB0J,EAAUJ,EAAUtJ,GAIxB,OAAOsJ,EAQT,SAASI,EAAUJ,EAAUI,GAE3B,IAAIjB,EAEJ,IAAKA,KAAOiB,EACV,GAAI7J,EAAIsF,KAAKuE,EAAWjB,GAAM,CAC5B,MAAMtE,EAAe,mBAARsE,GAAoC,eAARA,EAInCkB,GAHQ9J,EAAIsF,KAAKmE,EAAUb,GAAOa,EAASb,QAAOtI,KAGjCmJ,EAASb,GAAOtE,EAAO,GAAK,IAC7CyF,EAAQF,EAAUjB,GAEpBmB,IACEzF,EAEFmF,EAASb,GAAO,IAAIkB,KAASC,GAE7BlC,OAAOC,OAAOgC,EAAMC,KAQ9B,SAAShC,EAAe+B,EAAMC,GAC5B,MAAID,EACI,IAAIX,MACR,iBACEW,EAAKzI,KACL,OACA,OAAkB,CAChB2C,MAAO8F,EAAK9F,MACZ+B,IAAK+D,EAAK/D,MAEZ,0BACAgE,EAAM1I,KACN,OACA,OAAkB,CAChB2C,MAAO+F,EAAM/F,MACb+B,IAAKgE,EAAMhE,MAEb,aAGE,IAAIoD,MACR,oCACEY,EAAM1I,KACN,OACA,OAAkB,CAChB2C,MAAO+F,EAAM/F,MACb+B,IAAKgE,EAAMhE,MAEb","sources":["webpack://react-antd-admin/./node_modules/.pnpm/mdast-util-from-markdown@1.2.0/node_modules/mdast-util-from-markdown/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').ParseOptions} ParseOptions\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Value} Value\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('unist').Point} Point\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('mdast').Content} Content\n * @typedef {Root|Content} Node\n * @typedef {Extract<Node, UnistParent>} Parent\n * @typedef {import('mdast').Break} Break\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('mdast').Code} Code\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('mdast').HTML} HTML\n * @typedef {import('mdast').Image} Image\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Link} Link\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('mdast').List} List\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('mdast').Text} Text\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n *\n * @typedef {UnistParent & {type: 'fragment', children: Array<PhrasingContent>}} Fragment\n */\n\n/**\n * @typedef _CompileDataFields\n * @property {boolean|undefined} expectingFirstListItemValue\n * @property {boolean|undefined} flowCodeInside\n * @property {boolean|undefined} setextHeadingSlurpLineEnding\n * @property {boolean|undefined} atHardBreak\n * @property {'collapsed'|'full'} referenceType\n * @property {boolean|undefined} inReference\n * @property {'characterReferenceMarkerHexadecimal'|'characterReferenceMarkerNumeric'} characterReferenceType\n *\n * @typedef {Record<string, unknown> & Partial<_CompileDataFields>} CompileData\n *\n * @typedef {(tree: Root) => Root|void} Transform\n * @typedef {(this: CompileContext, token: Token) => void} Handle\n * @typedef {Record<string, Handle>} Handles\n *   Token types mapping to handles\n * @typedef {Record<string, Record<string, unknown>|Array<unknown>> & {canContainEols: Array<string>, transforms: Array<Transform>, enter: Handles, exit: Handles}} NormalizedExtension\n * @typedef {Partial<NormalizedExtension>} Extension\n *   An mdast extension changes how markdown tokens are turned into mdast.\n *\n * @typedef {(this: Omit<CompileContext, 'sliceSerialize'>, left: Token|undefined, right: Token) => void} OnEnterError\n * @typedef {(this: Omit<CompileContext, 'sliceSerialize'>, left: Token, right: Token) => void} OnExitError\n *\n * @typedef CompileContext\n *   mdast compiler context\n * @property {Array<Node | Fragment>} stack\n * @property {Array<[Token, OnEnterError|undefined]>} tokenStack\n * @property {(key: string, value?: unknown) => void} setData\n *   Set data into the key-value store.\n * @property {<K extends string>(key: K) => CompileData[K]} getData\n *   Get data from the key-value store.\n * @property {(this: CompileContext) => void} buffer\n *   Capture some of the output data.\n * @property {(this: CompileContext) => string} resume\n *   Stop capturing and access the output data.\n * @property {<N extends Node>(this: CompileContext, node: N, token: Token, onError?: OnEnterError) => N} enter\n *   Enter a token.\n * @property {(this: CompileContext, token: Token, onError?: OnExitError) => Node} exit\n *   Exit a token.\n * @property {TokenizeContext['sliceSerialize']} sliceSerialize\n *   Get the string value of a token.\n * @property {NormalizedExtension} config\n *   Configuration.\n *\n * @typedef {{mdastExtensions?: Array<Extension|Array<Extension>>}} FromMarkdownOptions\n * @typedef {ParseOptions & FromMarkdownOptions} Options\n */\nimport {toString} from 'mdast-util-to-string'\nimport {parse} from 'micromark/lib/parse.js'\nimport {preprocess} from 'micromark/lib/preprocess.js'\nimport {postprocess} from 'micromark/lib/postprocess.js'\nimport {decodeNumericCharacterReference} from 'micromark-util-decode-numeric-character-reference'\nimport {decodeString} from 'micromark-util-decode-string'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {decodeNamedCharacterReference} from 'decode-named-character-reference'\nimport {stringifyPosition} from 'unist-util-stringify-position'\nconst own = {}.hasOwnProperty\n/**\n * @param value Markdown to parse (`string` or `Buffer`).\n * @param [encoding] Character encoding to understand `value` as when it’s a `Buffer` (`string`, default: `'utf8'`).\n * @param [options] Configuration\n */\n\nexport const fromMarkdown =\n  /**\n   * @type {(\n   *   ((value: Value, encoding: Encoding, options?: Options) => Root) &\n   *   ((value: Value, options?: Options) => Root)\n   * )}\n   */\n\n  /**\n   * @param {Value} value\n   * @param {Encoding} [encoding]\n   * @param {Options} [options]\n   * @returns {Root}\n   */\n  function (value, encoding, options) {\n    if (typeof encoding !== 'string') {\n      options = encoding\n      encoding = undefined\n    }\n\n    return compiler(options)(\n      postprocess(\n        parse(options).document().write(preprocess()(value, encoding, true))\n      )\n    )\n  }\n/**\n * Note this compiler only understand complete buffering, not streaming.\n *\n * @param {Options} [options]\n */\n\nfunction compiler(options = {}) {\n  /** @type {NormalizedExtension} */\n  // @ts-expect-error: our base has all required fields, so the result will too.\n  const config = configure(\n    {\n      transforms: [],\n      canContainEols: [\n        'emphasis',\n        'fragment',\n        'heading',\n        'paragraph',\n        'strong'\n      ],\n      enter: {\n        autolink: opener(link),\n        autolinkProtocol: onenterdata,\n        autolinkEmail: onenterdata,\n        atxHeading: opener(heading),\n        blockQuote: opener(blockQuote),\n        characterEscape: onenterdata,\n        characterReference: onenterdata,\n        codeFenced: opener(codeFlow),\n        codeFencedFenceInfo: buffer,\n        codeFencedFenceMeta: buffer,\n        codeIndented: opener(codeFlow, buffer),\n        codeText: opener(codeText, buffer),\n        codeTextData: onenterdata,\n        data: onenterdata,\n        codeFlowValue: onenterdata,\n        definition: opener(definition),\n        definitionDestinationString: buffer,\n        definitionLabelString: buffer,\n        definitionTitleString: buffer,\n        emphasis: opener(emphasis),\n        hardBreakEscape: opener(hardBreak),\n        hardBreakTrailing: opener(hardBreak),\n        htmlFlow: opener(html, buffer),\n        htmlFlowData: onenterdata,\n        htmlText: opener(html, buffer),\n        htmlTextData: onenterdata,\n        image: opener(image),\n        label: buffer,\n        link: opener(link),\n        listItem: opener(listItem),\n        listItemValue: onenterlistitemvalue,\n        listOrdered: opener(list, onenterlistordered),\n        listUnordered: opener(list),\n        paragraph: opener(paragraph),\n        reference: onenterreference,\n        referenceString: buffer,\n        resourceDestinationString: buffer,\n        resourceTitleString: buffer,\n        setextHeading: opener(heading),\n        strong: opener(strong),\n        thematicBreak: opener(thematicBreak)\n      },\n      exit: {\n        atxHeading: closer(),\n        atxHeadingSequence: onexitatxheadingsequence,\n        autolink: closer(),\n        autolinkEmail: onexitautolinkemail,\n        autolinkProtocol: onexitautolinkprotocol,\n        blockQuote: closer(),\n        characterEscapeValue: onexitdata,\n        characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n        characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n        characterReferenceValue: onexitcharacterreferencevalue,\n        codeFenced: closer(onexitcodefenced),\n        codeFencedFence: onexitcodefencedfence,\n        codeFencedFenceInfo: onexitcodefencedfenceinfo,\n        codeFencedFenceMeta: onexitcodefencedfencemeta,\n        codeFlowValue: onexitdata,\n        codeIndented: closer(onexitcodeindented),\n        codeText: closer(onexitcodetext),\n        codeTextData: onexitdata,\n        data: onexitdata,\n        definition: closer(),\n        definitionDestinationString: onexitdefinitiondestinationstring,\n        definitionLabelString: onexitdefinitionlabelstring,\n        definitionTitleString: onexitdefinitiontitlestring,\n        emphasis: closer(),\n        hardBreakEscape: closer(onexithardbreak),\n        hardBreakTrailing: closer(onexithardbreak),\n        htmlFlow: closer(onexithtmlflow),\n        htmlFlowData: onexitdata,\n        htmlText: closer(onexithtmltext),\n        htmlTextData: onexitdata,\n        image: closer(onexitimage),\n        label: onexitlabel,\n        labelText: onexitlabeltext,\n        lineEnding: onexitlineending,\n        link: closer(onexitlink),\n        listItem: closer(),\n        listOrdered: closer(),\n        listUnordered: closer(),\n        paragraph: closer(),\n        referenceString: onexitreferencestring,\n        resourceDestinationString: onexitresourcedestinationstring,\n        resourceTitleString: onexitresourcetitlestring,\n        resource: onexitresource,\n        setextHeading: closer(onexitsetextheading),\n        setextHeadingLineSequence: onexitsetextheadinglinesequence,\n        setextHeadingText: onexitsetextheadingtext,\n        strong: closer(),\n        thematicBreak: closer()\n      }\n    },\n    options.mdastExtensions || []\n  )\n  /** @type {CompileData} */\n\n  const data = {}\n  return compile\n  /**\n   * @param {Array<Event>} events\n   * @returns {Root}\n   */\n\n  function compile(events) {\n    /** @type {Root} */\n    let tree = {\n      type: 'root',\n      children: []\n    }\n    /** @type {CompileContext['stack']} */\n\n    const stack = [tree]\n    /** @type {CompileContext['tokenStack']} */\n\n    const tokenStack = []\n    /** @type {Array<number>} */\n\n    const listStack = []\n    /** @type {Omit<CompileContext, 'sliceSerialize'>} */\n\n    const context = {\n      stack,\n      tokenStack,\n      config,\n      enter,\n      exit,\n      buffer,\n      resume,\n      setData,\n      getData\n    }\n    let index = -1\n\n    while (++index < events.length) {\n      // We preprocess lists to add `listItem` tokens, and to infer whether\n      // items the list itself are spread out.\n      if (\n        events[index][1].type === 'listOrdered' ||\n        events[index][1].type === 'listUnordered'\n      ) {\n        if (events[index][0] === 'enter') {\n          listStack.push(index)\n        } else {\n          const tail = listStack.pop()\n          index = prepareList(events, tail, index)\n        }\n      }\n    }\n\n    index = -1\n\n    while (++index < events.length) {\n      const handler = config[events[index][0]]\n\n      if (own.call(handler, events[index][1].type)) {\n        handler[events[index][1].type].call(\n          Object.assign(\n            {\n              sliceSerialize: events[index][2].sliceSerialize\n            },\n            context\n          ),\n          events[index][1]\n        )\n      }\n    }\n\n    if (tokenStack.length > 0) {\n      const tail = tokenStack[tokenStack.length - 1]\n      const handler = tail[1] || defaultOnError\n      handler.call(context, undefined, tail[0])\n    } // Figure out `root` position.\n\n    tree.position = {\n      start: point(\n        events.length > 0\n          ? events[0][1].start\n          : {\n              line: 1,\n              column: 1,\n              offset: 0\n            }\n      ),\n      end: point(\n        events.length > 0\n          ? events[events.length - 2][1].end\n          : {\n              line: 1,\n              column: 1,\n              offset: 0\n            }\n      )\n    }\n    index = -1\n\n    while (++index < config.transforms.length) {\n      tree = config.transforms[index](tree) || tree\n    }\n\n    return tree\n  }\n  /**\n   * @param {Array<Event>} events\n   * @param {number} start\n   * @param {number} length\n   * @returns {number}\n   */\n\n  function prepareList(events, start, length) {\n    let index = start - 1\n    let containerBalance = -1\n    let listSpread = false\n    /** @type {Token|undefined} */\n\n    let listItem\n    /** @type {number|undefined} */\n\n    let lineIndex\n    /** @type {number|undefined} */\n\n    let firstBlankLineIndex\n    /** @type {boolean|undefined} */\n\n    let atMarker\n\n    while (++index <= length) {\n      const event = events[index]\n\n      if (\n        event[1].type === 'listUnordered' ||\n        event[1].type === 'listOrdered' ||\n        event[1].type === 'blockQuote'\n      ) {\n        if (event[0] === 'enter') {\n          containerBalance++\n        } else {\n          containerBalance--\n        }\n\n        atMarker = undefined\n      } else if (event[1].type === 'lineEndingBlank') {\n        if (event[0] === 'enter') {\n          if (\n            listItem &&\n            !atMarker &&\n            !containerBalance &&\n            !firstBlankLineIndex\n          ) {\n            firstBlankLineIndex = index\n          }\n\n          atMarker = undefined\n        }\n      } else if (\n        event[1].type === 'linePrefix' ||\n        event[1].type === 'listItemValue' ||\n        event[1].type === 'listItemMarker' ||\n        event[1].type === 'listItemPrefix' ||\n        event[1].type === 'listItemPrefixWhitespace'\n      ) {\n        // Empty.\n      } else {\n        atMarker = undefined\n      }\n\n      if (\n        (!containerBalance &&\n          event[0] === 'enter' &&\n          event[1].type === 'listItemPrefix') ||\n        (containerBalance === -1 &&\n          event[0] === 'exit' &&\n          (event[1].type === 'listUnordered' ||\n            event[1].type === 'listOrdered'))\n      ) {\n        if (listItem) {\n          let tailIndex = index\n          lineIndex = undefined\n\n          while (tailIndex--) {\n            const tailEvent = events[tailIndex]\n\n            if (\n              tailEvent[1].type === 'lineEnding' ||\n              tailEvent[1].type === 'lineEndingBlank'\n            ) {\n              if (tailEvent[0] === 'exit') continue\n\n              if (lineIndex) {\n                events[lineIndex][1].type = 'lineEndingBlank'\n                listSpread = true\n              }\n\n              tailEvent[1].type = 'lineEnding'\n              lineIndex = tailIndex\n            } else if (\n              tailEvent[1].type === 'linePrefix' ||\n              tailEvent[1].type === 'blockQuotePrefix' ||\n              tailEvent[1].type === 'blockQuotePrefixWhitespace' ||\n              tailEvent[1].type === 'blockQuoteMarker' ||\n              tailEvent[1].type === 'listItemIndent'\n            ) {\n              // Empty\n            } else {\n              break\n            }\n          }\n\n          if (\n            firstBlankLineIndex &&\n            (!lineIndex || firstBlankLineIndex < lineIndex)\n          ) {\n            // @ts-expect-error Patched.\n            listItem._spread = true\n          } // Fix position.\n\n          listItem.end = Object.assign(\n            {},\n            lineIndex ? events[lineIndex][1].start : event[1].end\n          )\n          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]])\n          index++\n          length++\n        } // Create a new list item.\n\n        if (event[1].type === 'listItemPrefix') {\n          listItem = {\n            type: 'listItem',\n            // @ts-expect-error Patched\n            _spread: false,\n            start: Object.assign({}, event[1].start)\n          } // @ts-expect-error: `listItem` is most definitely defined, TS...\n\n          events.splice(index, 0, ['enter', listItem, event[2]])\n          index++\n          length++\n          firstBlankLineIndex = undefined\n          atMarker = true\n        }\n      }\n    } // @ts-expect-error Patched.\n\n    events[start][1]._spread = listSpread\n    return length\n  }\n  /**\n   * @type {CompileContext['setData']}\n   * @param [value]\n   */\n\n  function setData(key, value) {\n    data[key] = value\n  }\n  /**\n   * @type {CompileContext['getData']}\n   * @template {string} K\n   * @param {K} key\n   * @returns {CompileData[K]}\n   */\n\n  function getData(key) {\n    return data[key]\n  }\n  /**\n   * @param {Point} d\n   * @returns {Point}\n   */\n\n  function point(d) {\n    return {\n      line: d.line,\n      column: d.column,\n      offset: d.offset\n    }\n  }\n  /**\n   * @param {(token: Token) => Node} create\n   * @param {Handle} [and]\n   * @returns {Handle}\n   */\n\n  function opener(create, and) {\n    return open\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n\n    function open(token) {\n      enter.call(this, create(token), token)\n      if (and) and.call(this, token)\n    }\n  }\n  /** @type {CompileContext['buffer']} */\n\n  function buffer() {\n    this.stack.push({\n      type: 'fragment',\n      children: []\n    })\n  }\n  /**\n   * @type {CompileContext['enter']}\n   * @template {Node} N\n   * @this {CompileContext}\n   * @param {N} node\n   * @param {Token} token\n   * @param {OnEnterError} [errorHandler]\n   * @returns {N}\n   */\n\n  function enter(node, token, errorHandler) {\n    const parent = this.stack[this.stack.length - 1]\n    // @ts-expect-error: Assume `Node` can exist as a child of `parent`.\n    parent.children.push(node)\n    this.stack.push(node)\n    this.tokenStack.push([token, errorHandler]) // @ts-expect-error: `end` will be patched later.\n\n    node.position = {\n      start: point(token.start)\n    }\n    return node\n  }\n  /**\n   * @param {Handle} [and]\n   * @returns {Handle}\n   */\n\n  function closer(and) {\n    return close\n    /**\n     * @this {CompileContext}\n     * @param {Token} token\n     * @returns {void}\n     */\n\n    function close(token) {\n      if (and) and.call(this, token)\n      exit.call(this, token)\n    }\n  }\n  /**\n   * @type {CompileContext['exit']}\n   * @this {CompileContext}\n   * @param {Token} token\n   * @param {OnExitError} [onExitError]\n   * @returns {Node}\n   */\n\n  function exit(token, onExitError) {\n    const node = this.stack.pop()\n    const open = this.tokenStack.pop()\n\n    if (!open) {\n      throw new Error(\n        'Cannot close `' +\n          token.type +\n          '` (' +\n          stringifyPosition({\n            start: token.start,\n            end: token.end\n          }) +\n          '): it’s not open'\n      )\n    } else if (open[0].type !== token.type) {\n      if (onExitError) {\n        onExitError.call(this, token, open[0])\n      } else {\n        const handler = open[1] || defaultOnError\n        handler.call(this, token, open[0])\n      }\n    }\n\n    node.position.end = point(token.end)\n    return node\n  }\n  /**\n   * @this {CompileContext}\n   * @returns {string}\n   */\n\n  function resume() {\n    return toString(this.stack.pop())\n  } //\n  // Handlers.\n  //\n\n  /** @type {Handle} */\n\n  function onenterlistordered() {\n    setData('expectingFirstListItemValue', true)\n  }\n  /** @type {Handle} */\n\n  function onenterlistitemvalue(token) {\n    if (getData('expectingFirstListItemValue')) {\n      const ancestor =\n        /** @type {List} */\n        this.stack[this.stack.length - 2]\n      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10)\n      setData('expectingFirstListItemValue')\n    }\n  }\n  /** @type {Handle} */\n\n  function onexitcodefencedfenceinfo() {\n    const data = this.resume()\n    const node =\n      /** @type {Code} */\n      this.stack[this.stack.length - 1]\n    node.lang = data\n  }\n  /** @type {Handle} */\n\n  function onexitcodefencedfencemeta() {\n    const data = this.resume()\n    const node =\n      /** @type {Code} */\n      this.stack[this.stack.length - 1]\n    node.meta = data\n  }\n  /** @type {Handle} */\n\n  function onexitcodefencedfence() {\n    // Exit if this is the closing fence.\n    if (getData('flowCodeInside')) return\n    this.buffer()\n    setData('flowCodeInside', true)\n  }\n  /** @type {Handle} */\n\n  function onexitcodefenced() {\n    const data = this.resume()\n    const node =\n      /** @type {Code} */\n      this.stack[this.stack.length - 1]\n    node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    setData('flowCodeInside')\n  }\n  /** @type {Handle} */\n\n  function onexitcodeindented() {\n    const data = this.resume()\n    const node =\n      /** @type {Code} */\n      this.stack[this.stack.length - 1]\n    node.value = data.replace(/(\\r?\\n|\\r)$/g, '')\n  }\n  /** @type {Handle} */\n\n  function onexitdefinitionlabelstring(token) {\n    // Discard label, use the source content instead.\n    const label = this.resume()\n    const node =\n      /** @type {Definition} */\n      this.stack[this.stack.length - 1]\n    node.label = label\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n  }\n  /** @type {Handle} */\n\n  function onexitdefinitiontitlestring() {\n    const data = this.resume()\n    const node =\n      /** @type {Definition} */\n      this.stack[this.stack.length - 1]\n    node.title = data\n  }\n  /** @type {Handle} */\n\n  function onexitdefinitiondestinationstring() {\n    const data = this.resume()\n    const node =\n      /** @type {Definition} */\n      this.stack[this.stack.length - 1]\n    node.url = data\n  }\n  /** @type {Handle} */\n\n  function onexitatxheadingsequence(token) {\n    const node =\n      /** @type {Heading} */\n      this.stack[this.stack.length - 1]\n\n    if (!node.depth) {\n      const depth = this.sliceSerialize(token).length\n      node.depth = depth\n    }\n  }\n  /** @type {Handle} */\n\n  function onexitsetextheadingtext() {\n    setData('setextHeadingSlurpLineEnding', true)\n  }\n  /** @type {Handle} */\n\n  function onexitsetextheadinglinesequence(token) {\n    const node =\n      /** @type {Heading} */\n      this.stack[this.stack.length - 1]\n    node.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2\n  }\n  /** @type {Handle} */\n\n  function onexitsetextheading() {\n    setData('setextHeadingSlurpLineEnding')\n  }\n  /** @type {Handle} */\n\n  function onenterdata(token) {\n    const parent =\n      /** @type {Parent} */\n      this.stack[this.stack.length - 1]\n    /** @type {Node} */\n\n    let tail = parent.children[parent.children.length - 1]\n\n    if (!tail || tail.type !== 'text') {\n      // Add a new text node.\n      tail = text() // @ts-expect-error: we’ll add `end` later.\n\n      tail.position = {\n        start: point(token.start)\n      } // @ts-expect-error: Assume `parent` accepts `text`.\n\n      parent.children.push(tail)\n    }\n\n    this.stack.push(tail)\n  }\n  /** @type {Handle} */\n\n  function onexitdata(token) {\n    const tail = this.stack.pop()\n    tail.value += this.sliceSerialize(token)\n    tail.position.end = point(token.end)\n  }\n  /** @type {Handle} */\n\n  function onexitlineending(token) {\n    const context = this.stack[this.stack.length - 1]\n\n    // If we’re at a hard break, include the line ending in there.\n    if (getData('atHardBreak')) {\n      const tail = context.children[context.children.length - 1]\n      tail.position.end = point(token.end)\n      setData('atHardBreak')\n      return\n    }\n\n    if (\n      !getData('setextHeadingSlurpLineEnding') &&\n      config.canContainEols.includes(context.type)\n    ) {\n      onenterdata.call(this, token)\n      onexitdata.call(this, token)\n    }\n  }\n  /** @type {Handle} */\n\n  function onexithardbreak() {\n    setData('atHardBreak', true)\n  }\n  /** @type {Handle} */\n\n  function onexithtmlflow() {\n    const data = this.resume()\n    const node =\n      /** @type {HTML} */\n      this.stack[this.stack.length - 1]\n    node.value = data\n  }\n  /** @type {Handle} */\n\n  function onexithtmltext() {\n    const data = this.resume()\n    const node =\n      /** @type {HTML} */\n      this.stack[this.stack.length - 1]\n    node.value = data\n  }\n  /** @type {Handle} */\n\n  function onexitcodetext() {\n    const data = this.resume()\n    const node =\n      /** @type {InlineCode} */\n      this.stack[this.stack.length - 1]\n    node.value = data\n  }\n  /** @type {Handle} */\n\n  function onexitlink() {\n    const context =\n      /** @type {Link & {identifier: string, label: string}} */\n      this.stack[this.stack.length - 1] // To do: clean.\n\n    if (getData('inReference')) {\n      context.type += 'Reference' // @ts-expect-error: mutate.\n\n      context.referenceType = getData('referenceType') || 'shortcut' // @ts-expect-error: mutate.\n\n      delete context.url\n      delete context.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete context.identifier // @ts-expect-error: mutate.\n\n      delete context.label\n    }\n\n    setData('referenceType')\n  }\n  /** @type {Handle} */\n\n  function onexitimage() {\n    const context =\n      /** @type {Image & {identifier: string, label: string}} */\n      this.stack[this.stack.length - 1] // To do: clean.\n\n    if (getData('inReference')) {\n      context.type += 'Reference' // @ts-expect-error: mutate.\n\n      context.referenceType = getData('referenceType') || 'shortcut' // @ts-expect-error: mutate.\n\n      delete context.url\n      delete context.title\n    } else {\n      // @ts-expect-error: mutate.\n      delete context.identifier // @ts-expect-error: mutate.\n\n      delete context.label\n    }\n\n    setData('referenceType')\n  }\n  /** @type {Handle} */\n\n  function onexitlabeltext(token) {\n    const ancestor =\n      /** @type {(Link|Image) & {identifier: string, label: string}} */\n      this.stack[this.stack.length - 2]\n    const string = this.sliceSerialize(token)\n    ancestor.label = decodeString(string)\n    ancestor.identifier = normalizeIdentifier(string).toLowerCase()\n  }\n  /** @type {Handle} */\n\n  function onexitlabel() {\n    const fragment =\n      /** @type {Fragment} */\n      this.stack[this.stack.length - 1]\n    const value = this.resume()\n    const node =\n      /** @type {(Link|Image) & {identifier: string, label: string}} */\n      this.stack[this.stack.length - 1] // Assume a reference.\n\n    setData('inReference', true)\n\n    if (node.type === 'link') {\n      // @ts-expect-error: Assume static phrasing content.\n      node.children = fragment.children\n    } else {\n      node.alt = value\n    }\n  }\n  /** @type {Handle} */\n\n  function onexitresourcedestinationstring() {\n    const data = this.resume()\n    const node =\n      /** @type {Link|Image} */\n      this.stack[this.stack.length - 1]\n    node.url = data\n  }\n  /** @type {Handle} */\n\n  function onexitresourcetitlestring() {\n    const data = this.resume()\n    const node =\n      /** @type {Link|Image} */\n      this.stack[this.stack.length - 1]\n    node.title = data\n  }\n  /** @type {Handle} */\n\n  function onexitresource() {\n    setData('inReference')\n  }\n  /** @type {Handle} */\n\n  function onenterreference() {\n    setData('referenceType', 'collapsed')\n  }\n  /** @type {Handle} */\n\n  function onexitreferencestring(token) {\n    const label = this.resume()\n    const node =\n      /** @type {LinkReference|ImageReference} */\n      this.stack[this.stack.length - 1]\n    node.label = label\n    node.identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n    setData('referenceType', 'full')\n  }\n  /** @type {Handle} */\n\n  function onexitcharacterreferencemarker(token) {\n    setData('characterReferenceType', token.type)\n  }\n  /** @type {Handle} */\n\n  function onexitcharacterreferencevalue(token) {\n    const data = this.sliceSerialize(token)\n    const type = getData('characterReferenceType')\n    /** @type {string} */\n\n    let value\n\n    if (type) {\n      value = decodeNumericCharacterReference(\n        data,\n        type === 'characterReferenceMarkerNumeric' ? 10 : 16\n      )\n      setData('characterReferenceType')\n    } else {\n      // @ts-expect-error `decodeNamedCharacterReference` can return false for\n      // invalid named character references, but everything we’ve tokenized is\n      // valid.\n      value = decodeNamedCharacterReference(data)\n    }\n\n    const tail = this.stack.pop()\n    tail.value += value\n    tail.position.end = point(token.end)\n  }\n  /** @type {Handle} */\n\n  function onexitautolinkprotocol(token) {\n    onexitdata.call(this, token)\n    const node =\n      /** @type {Link} */\n      this.stack[this.stack.length - 1]\n    node.url = this.sliceSerialize(token)\n  }\n  /** @type {Handle} */\n\n  function onexitautolinkemail(token) {\n    onexitdata.call(this, token)\n    const node =\n      /** @type {Link} */\n      this.stack[this.stack.length - 1]\n    node.url = 'mailto:' + this.sliceSerialize(token)\n  } //\n  // Creaters.\n  //\n\n  /** @returns {Blockquote} */\n\n  function blockQuote() {\n    return {\n      type: 'blockquote',\n      children: []\n    }\n  }\n  /** @returns {Code} */\n\n  function codeFlow() {\n    return {\n      type: 'code',\n      lang: null,\n      meta: null,\n      value: ''\n    }\n  }\n  /** @returns {InlineCode} */\n\n  function codeText() {\n    return {\n      type: 'inlineCode',\n      value: ''\n    }\n  }\n  /** @returns {Definition} */\n\n  function definition() {\n    return {\n      type: 'definition',\n      identifier: '',\n      label: null,\n      title: null,\n      url: ''\n    }\n  }\n  /** @returns {Emphasis} */\n\n  function emphasis() {\n    return {\n      type: 'emphasis',\n      children: []\n    }\n  }\n  /** @returns {Heading} */\n\n  function heading() {\n    // @ts-expect-error `depth` will be set later.\n    return {\n      type: 'heading',\n      depth: undefined,\n      children: []\n    }\n  }\n  /** @returns {Break} */\n\n  function hardBreak() {\n    return {\n      type: 'break'\n    }\n  }\n  /** @returns {HTML} */\n\n  function html() {\n    return {\n      type: 'html',\n      value: ''\n    }\n  }\n  /** @returns {Image} */\n\n  function image() {\n    return {\n      type: 'image',\n      title: null,\n      url: '',\n      alt: null\n    }\n  }\n  /** @returns {Link} */\n\n  function link() {\n    return {\n      type: 'link',\n      title: null,\n      url: '',\n      children: []\n    }\n  }\n  /**\n   * @param {Token} token\n   * @returns {List}\n   */\n\n  function list(token) {\n    return {\n      type: 'list',\n      ordered: token.type === 'listOrdered',\n      start: null,\n      // @ts-expect-error Patched.\n      spread: token._spread,\n      children: []\n    }\n  }\n  /**\n   * @param {Token} token\n   * @returns {ListItem}\n   */\n\n  function listItem(token) {\n    return {\n      type: 'listItem',\n      // @ts-expect-error Patched.\n      spread: token._spread,\n      checked: null,\n      children: []\n    }\n  }\n  /** @returns {Paragraph} */\n\n  function paragraph() {\n    return {\n      type: 'paragraph',\n      children: []\n    }\n  }\n  /** @returns {Strong} */\n\n  function strong() {\n    return {\n      type: 'strong',\n      children: []\n    }\n  }\n  /** @returns {Text} */\n\n  function text() {\n    return {\n      type: 'text',\n      value: ''\n    }\n  }\n  /** @returns {ThematicBreak} */\n\n  function thematicBreak() {\n    return {\n      type: 'thematicBreak'\n    }\n  }\n}\n/**\n * @param {Extension} combined\n * @param {Array<Extension|Array<Extension>>} extensions\n * @returns {Extension}\n */\n\nfunction configure(combined, extensions) {\n  let index = -1\n\n  while (++index < extensions.length) {\n    const value = extensions[index]\n\n    if (Array.isArray(value)) {\n      configure(combined, value)\n    } else {\n      extension(combined, value)\n    }\n  }\n\n  return combined\n}\n/**\n * @param {Extension} combined\n * @param {Extension} extension\n * @returns {void}\n */\n\nfunction extension(combined, extension) {\n  /** @type {string} */\n  let key\n\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      const list = key === 'canContainEols' || key === 'transforms'\n      const maybe = own.call(combined, key) ? combined[key] : undefined\n      /* c8 ignore next */\n\n      const left = maybe || (combined[key] = list ? [] : {})\n      const right = extension[key]\n\n      if (right) {\n        if (list) {\n          // @ts-expect-error: `left` is an array.\n          combined[key] = [...left, ...right]\n        } else {\n          Object.assign(left, right)\n        }\n      }\n    }\n  }\n}\n/** @type {OnEnterError} */\n\nfunction defaultOnError(left, right) {\n  if (left) {\n    throw new Error(\n      'Cannot close `' +\n        left.type +\n        '` (' +\n        stringifyPosition({\n          start: left.start,\n          end: left.end\n        }) +\n        '): a different token (`' +\n        right.type +\n        '`, ' +\n        stringifyPosition({\n          start: right.start,\n          end: right.end\n        }) +\n        ') is open'\n    )\n  } else {\n    throw new Error(\n      'Cannot close document, a token (`' +\n        right.type +\n        '`, ' +\n        stringifyPosition({\n          start: right.start,\n          end: right.end\n        }) +\n        ') is still open'\n    )\n  }\n}\n"],"names":["own","hasOwnProperty","fromMarkdown","value","encoding","options","undefined","config","configure","transforms","canContainEols","enter","autolink","opener","link","autolinkProtocol","onenterdata","autolinkEmail","atxHeading","heading","blockQuote","type","children","characterEscape","characterReference","codeFenced","codeFlow","codeFencedFenceInfo","buffer","codeFencedFenceMeta","codeIndented","codeText","codeTextData","data","codeFlowValue","definition","identifier","label","title","url","definitionDestinationString","definitionLabelString","definitionTitleString","emphasis","hardBreakEscape","hardBreak","hardBreakTrailing","htmlFlow","html","htmlFlowData","htmlText","htmlTextData","image","alt","listItem","token","spread","_spread","checked","listItemValue","getData","this","stack","length","start","Number","parseInt","sliceSerialize","setData","listOrdered","list","listUnordered","paragraph","reference","referenceString","resourceDestinationString","resourceTitleString","setextHeading","strong","thematicBreak","exit","closer","atxHeadingSequence","node","depth","onexitdata","call","characterEscapeValue","characterReferenceMarkerHexadecimal","onexitcharacterreferencemarker","characterReferenceMarkerNumeric","characterReferenceValue","tail","pop","position","end","point","resume","replace","codeFencedFence","lang","meta","toLowerCase","onexithardbreak","context","referenceType","fragment","labelText","ancestor","string","lineEnding","includes","resource","setextHeadingLineSequence","charCodeAt","setextHeadingText","mdastExtensions","events","tree","tokenStack","listStack","index","push","prepareList","handler","Object","assign","defaultOnError","line","column","offset","lineIndex","firstBlankLineIndex","atMarker","containerBalance","listSpread","event","tailIndex","tailEvent","splice","key","d","create","and","errorHandler","onExitError","open","Error","parent","ordered","compiler","document","write","combined","extensions","Array","isArray","extension","left","right"],"sourceRoot":""}