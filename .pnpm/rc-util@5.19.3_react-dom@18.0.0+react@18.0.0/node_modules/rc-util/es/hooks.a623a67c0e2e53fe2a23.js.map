{"version":3,"file":".pnpm/rc-util@5.19.3_react-dom@18.0.0+react@18.0.0/node_modules/rc-util/es/hooks.a623a67c0e2e53fe2a23.js","mappings":"4HAMIA,GAAqD,E,QAAA,KAAc,kBAAwB,YAC/F,O,mECNe,SAASC,EAAQC,EAAUC,EAAWC,GACnD,IAAIC,EAAW,SAAa,IAO5B,MALM,UAAWA,EAASC,UAAYF,EAAaC,EAASC,QAAQH,UAAWA,KAC7EE,EAASC,QAAQC,MAAQL,IACzBG,EAASC,QAAQH,UAAYA,GAGxBE,EAASC,QAAQC,Q,uFCDX,SAASC,EAAmBC,EAAmBC,GAC5D,IAAIC,EAAOD,GAAU,GACjBE,EAAeD,EAAKC,aACpBL,EAAQI,EAAKJ,MACbM,EAAWF,EAAKE,SAChBC,EAAYH,EAAKG,UAEjBC,GAAY,QAAS,WACvB,YAAcC,IAAVT,EACKA,OAGYS,IAAjBJ,EAC6B,mBAAjBA,EAA8BA,IAAiBA,EAG3B,mBAAtBH,EAAmCA,IAAsBA,KAErEQ,GAAa,OAAeF,EAAW,GACvCG,EAAaD,EAAW,GACxBE,EAAgBF,EAAW,GAE3BG,OAAwBJ,IAAVT,EAAsBA,EAAQW,EAE5CJ,IACFM,EAAcN,EAAUM,IAI1B,IAAIC,EAAc,SAAaR,GAC/BQ,EAAYf,QAAUO,EACtB,IAAIS,EAAgB,eAAkB,SAAUC,EAAUC,GACxDL,EAAcI,EAAUC,GAEpBJ,IAAgBG,GAAYF,EAAYf,SAC1Ce,EAAYf,QAAQiB,EAAUH,KAE/B,CAACA,EAAaC,IAEbI,EAAiB,UAAa,GAWlC,OAVA,aAAgB,WACVA,EAAenB,QACjBmB,EAAenB,SAAU,OAIbU,IAAVT,GACFY,EAAcZ,KAEf,CAACA,IACG,CAACa,EAAaE,K,6EClDR,SAASI,EAASd,GAC/B,IAAIe,EAAa,UAAa,GAE1BC,EAAkB,WAAehB,GACjCiB,GAAmB,OAAeD,EAAiB,GACnDrB,EAAQsB,EAAiB,GACzBC,EAAWD,EAAiB,GAgBhC,OAdA,aAAgB,WACd,OAAO,WACLF,EAAWrB,SAAU,KAEtB,IAUI,CAACC,EARR,SAAsBwB,EAASP,GACzBA,GAAiBG,EAAWrB,SAIhCwB,EAASC","sources":["webpack://tech-stack/./node_modules/.pnpm/rc-util@5.19.3_react-dom@18.0.0+react@18.0.0/node_modules/rc-util/es/hooks/useLayoutEffect.js","webpack://tech-stack/./node_modules/.pnpm/rc-util@5.19.3_react-dom@18.0.0+react@18.0.0/node_modules/rc-util/es/hooks/useMemo.js","webpack://tech-stack/./node_modules/.pnpm/rc-util@5.19.3_react-dom@18.0.0+react@18.0.0/node_modules/rc-util/es/hooks/useMergedState.js","webpack://tech-stack/./node_modules/.pnpm/rc-util@5.19.3_react-dom@18.0.0+react@18.0.0/node_modules/rc-util/es/hooks/useState.js"],"sourcesContent":["import * as React from 'react';\nimport canUseDom from '../Dom/canUseDom';\n/**\n * Wrap `React.useLayoutEffect` which will not throw warning message in test env\n */\n\nvar useLayoutEffect = process.env.NODE_ENV !== 'test' && canUseDom() ? React.useLayoutEffect : React.useEffect;\nexport default useLayoutEffect;","import * as React from 'react';\nexport default function useMemo(getValue, condition, shouldUpdate) {\n  var cacheRef = React.useRef({});\n\n  if (!('value' in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {\n    cacheRef.current.value = getValue();\n    cacheRef.current.condition = condition;\n  }\n\n  return cacheRef.current.value;\n}","import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport * as React from 'react';\nimport useState from './useState';\n/**\n * Similar to `useState` but will use props value if provided.\n * Note that internal use rc-util `useState` hook.\n */\n\nexport default function useControlledState(defaultStateValue, option) {\n  var _ref = option || {},\n      defaultValue = _ref.defaultValue,\n      value = _ref.value,\n      onChange = _ref.onChange,\n      postState = _ref.postState;\n\n  var _useState = useState(function () {\n    if (value !== undefined) {\n      return value;\n    }\n\n    if (defaultValue !== undefined) {\n      return typeof defaultValue === 'function' ? defaultValue() : defaultValue;\n    }\n\n    return typeof defaultStateValue === 'function' ? defaultStateValue() : defaultStateValue;\n  }),\n      _useState2 = _slicedToArray(_useState, 2),\n      innerValue = _useState2[0],\n      setInnerValue = _useState2[1];\n\n  var mergedValue = value !== undefined ? value : innerValue;\n\n  if (postState) {\n    mergedValue = postState(mergedValue);\n  } // setState\n\n\n  var onChangeRef = React.useRef(onChange);\n  onChangeRef.current = onChange;\n  var triggerChange = React.useCallback(function (newValue, ignoreDestroy) {\n    setInnerValue(newValue, ignoreDestroy);\n\n    if (mergedValue !== newValue && onChangeRef.current) {\n      onChangeRef.current(newValue, mergedValue);\n    }\n  }, [mergedValue, onChangeRef]); // Effect of reset value to `undefined`\n\n  var firstRenderRef = React.useRef(true);\n  React.useEffect(function () {\n    if (firstRenderRef.current) {\n      firstRenderRef.current = false;\n      return;\n    }\n\n    if (value === undefined) {\n      setInnerValue(value);\n    }\n  }, [value]);\n  return [mergedValue, triggerChange];\n}","import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport * as React from 'react';\n/**\n * Same as React.useState but `setState` accept `ignoreDestroy` param to not to setState after destroyed.\n * We do not make this auto is to avoid real memory leak.\n * Developer should confirm it's safe to ignore themselves.\n */\n\nexport default function useState(defaultValue) {\n  var destroyRef = React.useRef(false);\n\n  var _React$useState = React.useState(defaultValue),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      value = _React$useState2[0],\n      setValue = _React$useState2[1];\n\n  React.useEffect(function () {\n    return function () {\n      destroyRef.current = true;\n    };\n  }, []);\n\n  function safeSetState(updater, ignoreDestroy) {\n    if (ignoreDestroy && destroyRef.current) {\n      return;\n    }\n\n    setValue(updater);\n  }\n\n  return [value, safeSetState];\n}"],"names":["useLayoutEffect","useMemo","getValue","condition","shouldUpdate","cacheRef","current","value","useControlledState","defaultStateValue","option","_ref","defaultValue","onChange","postState","_useState","undefined","_useState2","innerValue","setInnerValue","mergedValue","onChangeRef","triggerChange","newValue","ignoreDestroy","firstRenderRef","useState","destroyRef","_React$useState","_React$useState2","setValue","updater"],"sourceRoot":""}