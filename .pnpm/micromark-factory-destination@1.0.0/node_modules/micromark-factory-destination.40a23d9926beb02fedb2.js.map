{"version":3,"file":".pnpm/micromark-factory-destination@1.0.0/node_modules/micromark-factory-destination.40a23d9926beb02fedb2.js","mappings":"wKAuBO,SAASA,EACdC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA,MAAMC,EAAQD,GAAOE,OAAOC,kBAC5B,IAAIC,EAAU,EACd,OAGA,SAAeC,GACb,OAAa,KAATA,GACFb,EAAQc,MAAMX,GACdH,EAAQc,MAAMV,GACdJ,EAAQc,MAAMT,GACdL,EAAQe,QAAQF,GAChBb,EAAQgB,KAAKX,GACNY,GAGI,OAATJ,GAA0B,KAATA,IAAe,QAAaA,GACxCX,EAAIW,IAGbb,EAAQc,MAAMX,GACdH,EAAQc,MAAMR,GACdN,EAAQc,MAAMP,GACdP,EAAQc,MAAM,cAAe,CAC3BI,YAAa,WAERC,EAAeN,KAIxB,SAASI,EAA0BJ,GACjC,OAAa,KAATA,GACFb,EAAQc,MAAMT,GACdL,EAAQe,QAAQF,GAChBb,EAAQgB,KAAKX,GACbL,EAAQgB,KAAKZ,GACbJ,EAAQgB,KAAKb,GACNF,IAGTD,EAAQc,MAAMP,GACdP,EAAQc,MAAM,cAAe,CAC3BI,YAAa,WAERE,EAAoBP,IAI7B,SAASO,EAAoBP,GAC3B,OAAa,KAATA,GACFb,EAAQgB,KAAK,eACbhB,EAAQgB,KAAKT,GACNU,EAA0BJ,IAGtB,OAATA,GAA0B,KAATA,IAAe,QAAmBA,GAC9CX,EAAIW,IAGbb,EAAQe,QAAQF,GACA,KAATA,EAAcQ,EAA4BD,GAInD,SAASC,EAA0BR,GACjC,OAAa,KAATA,GAAwB,KAATA,GAAwB,KAATA,GAChCb,EAAQe,QAAQF,GACTO,GAGFA,EAAoBP,GAI7B,SAASM,EAAeN,GACtB,OAAa,KAATA,IACID,EAAUH,EAAcP,EAAIW,IAClCb,EAAQe,QAAQF,GACTM,GAGI,KAATN,EACGD,KAQLZ,EAAQe,QAAQF,GACTM,IARLnB,EAAQgB,KAAK,eACbhB,EAAQgB,KAAKT,GACbP,EAAQgB,KAAKV,GACbN,EAAQgB,KAAKb,GACNF,EAAGY,IAOD,OAATA,IAAiB,QAA0BA,GACzCD,EAAgBV,EAAIW,IACxBb,EAAQgB,KAAK,eACbhB,EAAQgB,KAAKT,GACbP,EAAQgB,KAAKV,GACbN,EAAQgB,KAAKb,GACNF,EAAGY,KAGR,QAAaA,GAAcX,EAAIW,IACnCb,EAAQe,QAAQF,GACA,KAATA,EAAcS,EAAuBH,GAI9C,SAASG,EAAqBT,GAC5B,OAAa,KAATA,GAAwB,KAATA,GAAwB,KAATA,GAChCb,EAAQe,QAAQF,GACTM,GAGFA,EAAeN","sources":["webpack://react-antd-admin/./node_modules/.pnpm/micromark-factory-destination@1.0.0/node_modules/micromark-factory-destination/index.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n */\nimport {\n  asciiControl,\n  markdownLineEndingOrSpace,\n  markdownLineEnding\n} from 'micromark-util-character'\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {State} nok\n * @param {string} type\n * @param {string} literalType\n * @param {string} literalMarkerType\n * @param {string} rawType\n * @param {string} stringType\n * @param {number} [max=Infinity]\n * @returns {State}\n */\n// eslint-disable-next-line max-params\nexport function factoryDestination(\n  effects,\n  ok,\n  nok,\n  type,\n  literalType,\n  literalMarkerType,\n  rawType,\n  stringType,\n  max\n) {\n  const limit = max || Number.POSITIVE_INFINITY\n  let balance = 0\n  return start\n  /** @type {State} */\n\n  function start(code) {\n    if (code === 60) {\n      effects.enter(type)\n      effects.enter(literalType)\n      effects.enter(literalMarkerType)\n      effects.consume(code)\n      effects.exit(literalMarkerType)\n      return destinationEnclosedBefore\n    }\n\n    if (code === null || code === 41 || asciiControl(code)) {\n      return nok(code)\n    }\n\n    effects.enter(type)\n    effects.enter(rawType)\n    effects.enter(stringType)\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return destinationRaw(code)\n  }\n  /** @type {State} */\n\n  function destinationEnclosedBefore(code) {\n    if (code === 62) {\n      effects.enter(literalMarkerType)\n      effects.consume(code)\n      effects.exit(literalMarkerType)\n      effects.exit(literalType)\n      effects.exit(type)\n      return ok\n    }\n\n    effects.enter(stringType)\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return destinationEnclosed(code)\n  }\n  /** @type {State} */\n\n  function destinationEnclosed(code) {\n    if (code === 62) {\n      effects.exit('chunkString')\n      effects.exit(stringType)\n      return destinationEnclosedBefore(code)\n    }\n\n    if (code === null || code === 60 || markdownLineEnding(code)) {\n      return nok(code)\n    }\n\n    effects.consume(code)\n    return code === 92 ? destinationEnclosedEscape : destinationEnclosed\n  }\n  /** @type {State} */\n\n  function destinationEnclosedEscape(code) {\n    if (code === 60 || code === 62 || code === 92) {\n      effects.consume(code)\n      return destinationEnclosed\n    }\n\n    return destinationEnclosed(code)\n  }\n  /** @type {State} */\n\n  function destinationRaw(code) {\n    if (code === 40) {\n      if (++balance > limit) return nok(code)\n      effects.consume(code)\n      return destinationRaw\n    }\n\n    if (code === 41) {\n      if (!balance--) {\n        effects.exit('chunkString')\n        effects.exit(stringType)\n        effects.exit(rawType)\n        effects.exit(type)\n        return ok(code)\n      }\n\n      effects.consume(code)\n      return destinationRaw\n    }\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      if (balance) return nok(code)\n      effects.exit('chunkString')\n      effects.exit(stringType)\n      effects.exit(rawType)\n      effects.exit(type)\n      return ok(code)\n    }\n\n    if (asciiControl(code)) return nok(code)\n    effects.consume(code)\n    return code === 92 ? destinationRawEscape : destinationRaw\n  }\n  /** @type {State} */\n\n  function destinationRawEscape(code) {\n    if (code === 40 || code === 41 || code === 92) {\n      effects.consume(code)\n      return destinationRaw\n    }\n\n    return destinationRaw(code)\n  }\n}\n"],"names":["factoryDestination","effects","ok","nok","type","literalType","literalMarkerType","rawType","stringType","max","limit","Number","POSITIVE_INFINITY","balance","code","enter","consume","exit","destinationEnclosedBefore","contentType","destinationRaw","destinationEnclosed","destinationEnclosedEscape","destinationRawEscape"],"sourceRoot":""}